---
title: "Longest Palindromic Substring"
summary: "Given a string s, return the longest palindromic substring in s."
date: "Sep 07, 2025"
tags:
  - Two Pointers
  - String
  - Dynamic Programming
draft: false
difficulty: "Medium"
---

import CodeTabs from "@components/CodeTabs"

> **Difficulty:** Medium | **Acceptance:** 36.30% | **Paid:** No

> **Topics:** Two Pointers, String, Dynamic Programming

- Examples
- Constraints
- [Brute Force Approach](#brute-force-approach)
- [Expand Around Centers](#expand-around-centers)
- [Dynamic Programming](#dynamic-programming)

## Examples

**Input**

```text
s = "babad"
```

**Output**

```text
"bab"
```

**Explanation**

"aba" is also a valid answer.

**Input**

```text
s = "cbbd"
```

**Output**

```text
"bb"
```

## Constraints

```text
- 1 <= s.length <= 1000
- s consists of only digits and English letters.
```
---

## Brute Force Approach

**Intuition**

Check every possible substring to see if it's a palindrome and keep track of the longest one found.

**Steps**

- Generate all possible substrings of the input string.
- For each substring, check if it is a palindrome.
- Keep track of the longest palindromic substring found so far.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def longestPalindrome(s: str) -> str:
    def is_palindrome(sub):
        return sub == sub[::-1]
    
    n = len(s)
    longest = ""
    
    for i in range(n):
        for j in range(i, n):
            substring = s[i:j+1]
            if is_palindrome(substring) and len(substring) > len(longest):
                longest = substring
    
    return longest` },
{ name: "Java", lang: "java", code: `public class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        String longest = "";
        
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                String substring = s.substring(i, j + 1);
                if (isPalindrome(substring) && substring.length() > longest.length()) {
                    longest = substring;
                }
            }
        }
        
        return longest;
    }
    
    private boolean isPalindrome(String str) {
        int left = 0;
        int right = str.length() - 1;
        
        while (left < right) {
            if (str.charAt(left) != str.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `function longestPalindrome(s) {
    function isPalindrome(str) {
        let left = 0;
        let right = str.length - 1;
        
        while (left < right) {
            if (str[left] !== str[right]) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
    
    let n = s.length;
    let longest = "";
    
    for (let i = 0; i < n; i++) {
        for (let j = i; j < n; j++) {
            let substring = s.substring(i, j + 1);
            if (isPalindrome(substring) && substring.length > longest.length) {
                longest = substring;
            }
        }
    }
    
    return longest;
}` },
{ name: "C++", lang: "cpp", code: `#include <string>
#include <algorithm>
using namespace std;

class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.length();
        string longest = "";
        
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                string substring = s.substr(i, j - i + 1);
                if (isPalindrome(substring) && substring.length() > longest.length()) {
                    longest = substring;
                }
            }
        }
        
        return longest;
    }
    
private:
    bool isPalindrome(string str) {
        int left = 0;
        int right = str.length() - 1;
        
        while (left < right) {
            if (str[left] != str[right]) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
};` },
{ name: "Python3", lang: "python", code: `class Solution:
    def longestPalindrome(self, s: str) -> str:
        def is_palindrome(sub):
            return sub == sub[::-1]
        
        n = len(s)
        longest = ""
        
        for i in range(n):
            for j in range(i, n):
                substring = s[i:j+1]
                if is_palindrome(substring) and len(substring) > len(longest):
                    longest = substring
        
        return longest` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int is_palindrome(char* str, int len) {
    int left = 0;
    int right = len - 1;
    
    while (left < right) {
        if (str[left] != str[right]) {
            return 0;
        }
        left++;
        right--;
    }
    
    return 1;
}

char* longestPalindrome(char* s) {
    int n = strlen(s);
    char* longest = (char*)malloc((n + 1) * sizeof(char));
    longest[0] = '\0';
    
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            int len = j - i + 1;
            char* substring = (char*)malloc((len + 1) * sizeof(char));
            strncpy(substring, s + i, len);
            substring[len] = '\0';
            
            if (is_palindrome(substring, len) && len > strlen(longest)) {
                strcpy(longest, substring);
            }
            
            free(substring);
        }
    }
    
    return longest;
}` },
{ name: "C#", lang: "csharp", code: `public class Solution {
    public string LongestPalindrome(string s) {
        int n = s.Length;
        string longest = "";
        
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                string substring = s.Substring(i, j - i + 1);
                if (IsPalindrome(substring) && substring.Length > longest.Length) {
                    longest = substring;
                }
            }
        }
        
        return longest;
    }
    
    private bool IsPalindrome(string str) {
        int left = 0;
        int right = str.Length - 1;
        
        while (left < right) {
            if (str[left] != str[right]) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function longestPalindrome(s: string): string {
    function isPalindrome(str: string): boolean {
        let left = 0;
        let right = str.length - 1;
        
        while (left < right) {
            if (str[left] !== str[right]) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
    
    let n = s.length;
    let longest = "";
    
    for (let i = 0; i < n; i++) {
        for (let j = i; j < n; j++) {
            let substring = s.substring(i, j + 1);
            if (isPalindrome(substring) && substring.length > longest.length) {
                longest = substring;
            }
        }
    }
    
    return longest;
}` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func longestPalindrome(_ s: String) -> String {
        let chars = Array(s)
        var longest = ""
        
        for i in 0..<chars.count {
            for j in i..<chars.count {
                let substring = String(chars[i...j])
                if isPalindrome(substring) && substring.count > longest.count {
                    longest = substring
                }
            }
        }
        
        return longest
    }
    
    private func isPalindrome(_ str: String) -> Bool {
        let chars = Array(str)
        var left = 0
        var right = chars.count - 1
        
        while left < right {
            if chars[left] != chars[right] {
                return false
            }
            left += 1
            right -= 1
        }
        
        return true
    }
}` }]} />

**Complexity**

- Time: O(n^3)
- Space: O(1)
- Notes: The time complexity is O(n^3) because we generate all O(n^2) substrings and check each one for palindrome property in O(n) time. Space complexity is O(1) as we only store a few variables.

---

## Expand Around Centers

**Intuition**

A palindrome can be expanded from its center. We can iterate through all possible centers and expand around them to find the longest palindrome.

**Steps**

- Iterate through each character in the string as a potential center of a palindrome.
- For each center, expand outward in both directions as long as the characters match.
- Handle both odd-length palindromes (single character center) and even-length palindromes (between two characters).
- Keep track of the longest palindrome found during the expansion process.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def longestPalindrome(s: str) -> str:
    if not s:
        return ""
    
    start = 0
    max_len = 1
    
    def expand_around_center(left: int, right: int):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return right - left - 1
    
    for i in range(len(s)):
        len1 = expand_around_center(i, i)  # Odd length palindromes
        len2 = expand_around_center(i, i + 1)  # Even length palindromes
        current_max = max(len1, len2)
        
        if current_max > max_len:
            max_len = current_max
            start = i - (current_max - 1) // 2
    
    return s[start:start + max_len]` },
{ name: "Java", lang: "java", code: `public class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) return "";
        
        int start = 0, end = 0;
        
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);     // Odd length palindromes
            int len2 = expandAroundCenter(s, i, i + 1); // Even length palindromes
            int len = Math.max(len1, len2);
            
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        
        return s.substring(start, end + 1);
    }
    
    private int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `function longestPalindrome(s) {
    if (!s || s.length < 1) return "";
    
    let start = 0, end = 0;
    
    function expandAroundCenter(left, right) {
        while (left >= 0 && right < s.length && s[left] === s[right]) {
            left--;
            right++;
        }
        return right - left - 1;
    }
    
    for (let i = 0; i < s.length; i++) {
        let len1 = expandAroundCenter(i, i);     // Odd length palindromes
        let len2 = expandAroundCenter(i, i + 1); // Even length palindromes
        let len = Math.max(len1, len2);
        
        if (len > end - start) {
            start = i - Math.floor((len - 1) / 2);
            end = i + Math.floor(len / 2);
        }
    }
    
    return s.substring(start, end + 1);
}` },
{ name: "C++", lang: "cpp", code: `#include <string>
#include <algorithm>
using namespace std;

class Solution {
public:
    string longestPalindrome(string s) {
        if (s.empty()) return "";
        
        int start = 0, maxLen = 0;
        
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);     // Odd length palindromes
            int len2 = expandAroundCenter(s, i, i + 1); // Even length palindromes
            int len = max(len1, len2);
            
            if (len > maxLen) {
                maxLen = len;
                start = i - (len - 1) / 2;
            }
        }
        
        return s.substr(start, maxLen);
    }
    
private:
    int expandAroundCenter(string s, int left, int right) {
        while (left >= 0 && right < s.length() && s[left] == s[right]) {
            left--;
            right++;
        }
        return right - left - 1;
    }
};` },
{ name: "Python3", lang: "python", code: `class Solution:
    def longestPalindrome(self, s: str) -> str:
        if not s:
            return ""
        
        start = 0
        max_len = 1
        
        def expand_around_center(left: int, right: int) -> int:
            while left >= 0 and right < len(s) and s[left] == s[right]:
                left -= 1
                right += 1
            return right - left - 1
        
        for i in range(len(s)):
            len1 = expand_around_center(i, i)  # Odd length palindromes
            len2 = expand_around_center(i, i + 1)  # Even length palindromes
            current_max = max(len1, len2)
            
            if current_max > max_len:
                max_len = current_max
                start = i - (current_max - 1) // 2
        
        return s[start:start + max_len]` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int expandAroundCenter(char* s, int left, int right) {
    while (left >= 0 && right < strlen(s) && s[left] == s[right]) {
        left--;
        right++;
    }
    return right - left - 1;
}

char* longestPalindrome(char* s) {
    if (!s || strlen(s) < 1) {
        char* result = (char*)malloc(1 * sizeof(char));
        result[0] = '\0';
        return result;
    }
    
    int start = 0, maxLen = 0;
    
    for (int i = 0; i < strlen(s); i++) {
        int len1 = expandAroundCenter(s, i, i);     // Odd length palindromes
        int len2 = expandAroundCenter(s, i, i + 1); // Even length palindromes
        int len = len1 > len2 ? len1 : len2;
        
        if (len > maxLen) {
            maxLen = len;
            start = i - (len - 1) / 2;
        }
    }
    
    char* result = (char*)malloc((maxLen + 1) * sizeof(char));
    strncpy(result, s + start, maxLen);
    result[maxLen] = '\0';
    
    return result;
}` },
{ name: "C#", lang: "csharp", code: `public class Solution {
    public string LongestPalindrome(string s) {
        if (string.IsNullOrEmpty(s)) return "";
        
        int start = 0, end = 0;
        
        for (int i = 0; i < s.Length; i++) {
            int len1 = ExpandAroundCenter(s, i, i);     // Odd length palindromes
            int len2 = ExpandAroundCenter(s, i, i + 1); // Even length palindromes
            int len = Math.Max(len1, len2);
            
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        
        return s.Substring(start, end - start + 1);
    }
    
    private int ExpandAroundCenter(string s, int left, int right) {
        while (left >= 0 && right < s.Length && s[left] == s[right]) {
            left--;
            right++;
        }
        return right - left - 1;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function longestPalindrome(s: string): string {
    if (!s || s.length < 1) return "";
    
    let start = 0, end = 0;
    
    function expandAroundCenter(left: number, right: number): number {
        while (left >= 0 && right < s.length && s[left] === s[right]) {
            left--;
            right++;
        }
        return right - left - 1;
    }
    
    for (let i = 0; i < s.length; i++) {
        let len1 = expandAroundCenter(i, i);     // Odd length palindromes
        let len2 = expandAroundCenter(i, i + 1); // Even length palindromes
        let len = Math.max(len1, len2);
        
        if (len > end - start) {
            start = i - Math.floor((len - 1) / 2);
            end = i + Math.floor(len / 2);
        }
    }
    
    return s.substring(start, end + 1);
}` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func longestPalindrome(_ s: String) -> String {
        if s.isEmpty { return "" }
        
        let chars = Array(s)
        var start = 0
        var maxLength = 0
        
        func expandAroundCenter(_ left: Int, _ right: Int) -> Int {
            var l = left
            var r = right
            
            while l >= 0 && r < chars.count && chars[l] == chars[r] {
                l -= 1
                r += 1
            }
            
            return r - l - 1
        }
        
        for i in 0..<chars.count {
            let len1 = expandAroundCenter(i, i)      // Odd length palindromes
            let len2 = expandAroundCenter(i, i + 1)  // Even length palindromes
            let len = max(len1, len2)
            
            if len > maxLength {
                maxLength = len
                start = i - (len - 1) / 2
            }
        }
        
        return String(chars[start..<start + maxLength])
    }
}` }]} />

**Complexity**

- Time: O(n^2)
- Space: O(1)
- Notes: The time complexity is O(n^2) because we iterate through each character (n) and potentially expand to both ends (n in worst case). Space complexity is O(1) as we only use a few variables.

---

## Dynamic Programming

**Intuition**

Use dynamic programming to store whether substrings are palindromes, building up from smaller substrings to larger ones.

**Steps**

- Create a 2D boolean array dp where dp[i][j] represents whether the substring from index i to j is a palindrome.
- Initialize the base cases: single characters are palindromes, and check for two-character palindromes.
- For substrings of length 3 and above, a substring s[i...j] is a palindrome if s[i] == s[j] and s[i+1...j-1] is a palindrome.
- Keep track of the longest palindromic substring found during the DP filling process.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def longestPalindrome(s: str) -> str:
    if not s:
        return ""
    
    n = len(s)
    # dp[i][j] will be True if substring s[i:j+1] is palindrome
    dp = [[False] * n for _ in range(n)]
    
    start = 0
    max_len = 1
    
    # All substrings of length 1 are palindromes
    for i in range(n):
        dp[i][i] = True
    
    # Check for substrings of length 2
    for i in range(n - 1):
        if s[i] == s[i + 1]:
            dp[i][i + 1] = True
            start = i
            max_len = 2
    
    # Check for substrings of length 3 and more
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            
            # Check if s[i:j+1] is palindrome
            if s[i] == s[j] and dp[i + 1][j - 1]:
                dp[i][j] = True
                
                if length > max_len:
                    start = i
                    max_len = length
    
    return s[start:start + max_len]` },
{ name: "Java", lang: "java", code: `public class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) return "";
        
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        
        int start = 0;
        int maxLen = 1;
        
        // All substrings of length 1 are palindromes
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }
        
        // Check for substrings of length 2
        for (int i = 0; i < n - 1; i++) {
            if (s.charAt(i) == s.charAt(i + 1)) {
                dp[i][i + 1] = true;
                start = i;
                maxLen = 2;
            }
        }
        
        // Check for substrings of length 3 and more
        for (int len = 3; len <= n; len++) {
            for (int i = 0; i < n - len + 1; i++) {
                int j = i + len - 1;
                
                // Check if s[i:j] is palindrome
                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                    
                    if (len > maxLen) {
                        start = i;
                        maxLen = len;
                    }
                }
            }
        }
        
        return s.substring(start, start + maxLen);
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `function longestPalindrome(s) {
    if (!s || s.length < 1) return "";
    
    const n = s.length;
    // dp[i][j] will be true if substring s[i:j+1] is palindrome
    const dp = Array(n).fill(null).map(() => Array(n).fill(false));
    
    let start = 0;
    let maxLen = 1;
    
    // All substrings of length 1 are palindromes
    for (let i = 0; i < n; i++) {
        dp[i][i] = true;
    }
    
    // Check for substrings of length 2
    for (let i = 0; i < n - 1; i++) {
        if (s[i] === s[i + 1]) {
            dp[i][i + 1] = true;
            start = i;
            maxLen = 2;
        }
    }
    
    // Check for substrings of length 3 and more
    for (let len = 3; len <= n; len++) {
        for (let i = 0; i < n - len + 1; i++) {
            let j = i + len - 1;
            
            // Check if s[i:j+1] is palindrome
            if (s[i] === s[j] && dp[i + 1][j - 1]) {
                dp[i][j] = true;
                
                if (len > maxLen) {
                    start = i;
                    maxLen = len;
                }
            }
        }
    }
    
    return s.substring(start, start + maxLen);
}` },
{ name: "C++", lang: "cpp", code: `#include <string>
#include <vector>
using namespace std;

class Solution {
public:
    string longestPalindrome(string s) {
        if (s.empty()) return "";
        
        int n = s.length();
        // dp[i][j] will be true if substring s[i:j+1] is palindrome
        vector<vector<bool>> dp(n, vector<bool>(n, false));
        
        int start = 0;
        int maxLen = 1;
        
        // All substrings of length 1 are palindromes
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }
        
        // Check for substrings of length 2
        for (int i = 0; i < n - 1; i++) {
            if (s[i] == s[i + 1]) {
                dp[i][i + 1] = true;
                start = i;
                maxLen = 2;
            }
        }
        
        // Check for substrings of length 3 and more
        for (int len = 3; len <= n; len++) {
            for (int i = 0; i < n - len + 1; i++) {
                int j = i + len - 1;
                
                // Check if s[i:j+1] is palindrome
                if (s[i] == s[j] && dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                    
                    if (len > maxLen) {
                        start = i;
                        maxLen = len;
                    }
                }
            }
        }
        
        return s.substr(start, maxLen);
    }
};` },
{ name: "Python3", lang: "python", code: `class Solution:
    def longestPalindrome(self, s: str) -> str:
        if not s:
            return ""
        
        n = len(s)
        # dp[i][j] will be True if substring s[i:j+1] is palindrome
        dp = [[False] * n for _ in range(n)]
        
        start = 0
        max_len = 1
        
        # All substrings of length 1 are palindromes
        for i in range(n):
            dp[i][i] = True
        
        # Check for substrings of length 2
        for i in range(n - 1):
            if s[i] == s[i + 1]:
                dp[i][i + 1] = True
                start = i
                max_len = 2
        
        # Check for substrings of length 3 and more
        for length in range(3, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                
                # Check if s[i:j+1] is palindrome
                if s[i] == s[j] and dp[i + 1][j - 1]:
                    dp[i][j] = True
                    
                    if length > max_len:
                        start = i
                        max_len = length
        
        return s[start:start + max_len]` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* longestPalindrome(char* s) {
    if (!s || strlen(s) < 1) {
        char* result = (char*)malloc(1 * sizeof(char));
        result[0] = '\0';
        return result;
    }
    
    int n = strlen(s);
    // dp[i][j] will be 1 if substring s[i:j+1] is palindrome
    int** dp = (int**)malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++) {
        dp[i] = (int*)calloc(n, sizeof(int));
    }
    
    int start = 0;
    int maxLen = 1;
    
    // All substrings of length 1 are palindromes
    for (int i = 0; i < n; i++) {
        dp[i][i] = 1;
    }
    
    // Check for substrings of length 2
    for (int i = 0; i < n - 1; i++) {
        if (s[i] == s[i + 1]) {
            dp[i][i + 1] = 1;
            start = i;
            maxLen = 2;
        }
    }
    
    // Check for substrings of length 3 and more
    for (int len = 3; len <= n; len++) {
        for (int i = 0; i < n - len + 1; i++) {
            int j = i + len - 1;
            
            // Check if s[i:j+1] is palindrome
            if (s[i] == s[j] && dp[i + 1][j - 1]) {
                dp[i][j] = 1;
                
                if (len > maxLen) {
                    start = i;
                    maxLen = len;
                }
            }
        }
    }
    
    char* result = (char*)malloc((maxLen + 1) * sizeof(char));
    strncpy(result, s + start, maxLen);
    result[maxLen] = '\0';
    
    // Free allocated memory
    for (int i = 0; i < n; i++) {
        free(dp[i]);
    }
    free(dp);
    
    return result;
}` },
{ name: "C#", lang: "csharp", code: `public class Solution {
    public string LongestPalindrome(string s) {
        if (string.IsNullOrEmpty(s)) return "";
        
        int n = s.Length;
        bool[,] dp = new bool[n, n];
        
        int start = 0;
        int maxLen = 1;
        
        // All substrings of length 1 are palindromes
        for (int i = 0; i < n; i++) {
            dp[i, i] = true;
        }
        
        // Check for substrings of length 2
        for (int i = 0; i < n - 1; i++) {
            if (s[i] == s[i + 1]) {
                dp[i, i + 1] = true;
                start = i;
                maxLen = 2;
            }
        }
        
        // Check for substrings of length 3 and more
        for (int len = 3; len <= n; len++) {
            for (int i = 0; i < n - len + 1; i++) {
                int j = i + len - 1;
                
                // Check if s[i:j+1] is palindrome
                if (s[i] == s[j] && dp[i + 1, j - 1]) {
                    dp[i, j] = true;
                    
                    if (len > maxLen) {
                        start = i;
                        maxLen = len;
                    }
                }
            }
        }
        
        return s.Substring(start, maxLen);
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function longestPalindrome(s: string): string {
    if (!s || s.length < 1) return "";
    
    const n = s.length;
    // dp[i][j] will be true if substring s[i:j+1] is palindrome
    const dp: boolean[][] = Array(n).fill(null).map(() => Array(n).fill(false));
    
    let start = 0;
    let maxLen = 1;
    
    // All substrings of length 1 are palindromes
    for (let i = 0; i < n; i++) {
        dp[i][i] = true;
    }
    
    // Check for substrings of length 2
    for (let i = 0; i < n - 1; i++) {
        if (s[i] === s[i + 1]) {
            dp[i][i + 1] = true;
            start = i;
            maxLen = 2;
        }
    }
    
    // Check for substrings of length 3 and more
    for (let len = 3; len <= n; len++) {
        for (let i = 0; i < n - len + 1; i++) {
            let j = i + len - 1;
            
            // Check if s[i:j+1] is palindrome
            if (s[i] === s[j] && dp[i + 1][j - 1]) {
                dp[i][j] = true;
                
                if (len > maxLen) {
                    start = i;
                    maxLen = len;
                }
            }
        }
    }
    
    return s.substring(start, start + maxLen);
}` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func longestPalindrome(_ s: String) -> String {
        if s.isEmpty { return "" }
        
        let chars = Array(s)
        let n = chars.count
        // dp[i][j] will be true if substring s[i:j+1] is palindrome
        var dp = Array(repeating: Array(repeating: false, count: n), count: n)
        
        var start = 0
        var maxLen = 1
        
        // All substrings of length 1 are palindromes
        for i in 0..<n {
            dp[i][i] = true
        }
        
        // Check for substrings of length 2
        for i in 0..<n-1 {
            if chars[i] == chars[i + 1] {
                dp[i][i + 1] = true
                start = i
                maxLen = 2
            }
        }
        
        // Check for substrings of length 3 and more
        for length in 3...n {
            for i in 0..<n-length+1 {
                let j = i + length - 1
                
                // Check if chars[i:j+1] is palindrome
                if chars[i] == chars[j] && dp[i + 1][j - 1] {
                    dp[i][j] = true
                    
                    if length > maxLen {
                        start = i
                        maxLen = length
                    }
                }
            }
        }
        
        return String(chars[start..<start + maxLen])
    }
}` }]} />

**Complexity**

- Time: O(n^2)
- Space: O(n^2)
- Notes: The time complexity is O(n^2) as we fill the 2D DP table. Space complexity is O(n^2) for storing the DP table. This approach trades space for time compared to the expand around centers approach.


<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"TechArticle","headline":"LeetCode Longest Palindromic Substring Solutions","datePublished":"2025-09-07T18:44:31.051Z","description":"Given a string s, return the longest palindromic substring in s.","keywords":"LeetCode, Longest Palindromic Substring, Medium, Two Pointers, String, Dynamic Programming, Hash Map, Brute Force, Array"}).replace(/</g,'\\u003c')}
</script>

<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"Brute Force Approach complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n^3); Space: O(1). The time complexity is O(n^3) because we generate all O(n^2) substrings and check each one for palindrome property in O(n) time. Space complexity is O(1) as we only store a few variables."}},{"@type":"Question","name":"Expand Around Centers complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n^2); Space: O(1). The time complexity is O(n^2) because we iterate through each character (n) and potentially expand to both ends (n in worst case). Space complexity is O(1) as we only use a few variables."}},{"@type":"Question","name":"Dynamic Programming complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n^2); Space: O(n^2). The time complexity is O(n^2) as we fill the 2D DP table. Space complexity is O(n^2) for storing the DP table. This approach trades space for time compared to the expand around centers approach."}}]}).replace(/</g,'\\u003c')}
</script>
