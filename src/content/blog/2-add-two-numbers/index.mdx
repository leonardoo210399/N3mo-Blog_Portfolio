---
title: "Add Two Numbers"
summary: "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself."
date: "Sep 07, 2025"
tags:
  - Linked List
  - Math
  - Recursion
draft: false
difficulty: "Medium"
---

import CodeTabs from "@components/CodeTabs"

> **Difficulty:** Medium | **Acceptance:** 46.79% | **Paid:** No

> **Topics:** Linked List, Math, Recursion

- Examples
- Constraints
- [Elementary Math](#elementary-math)
- [Recursive Approach](#recursive-approach)
- [Optimized Iterative with Early Termination](#optimized-iterative-with-early-termination)

## Examples

**Input**

```text
l1 = [2,4,3], l2 = [5,6,4]
```

**Output**

```text
[7,0,8]
```

**Explanation**

342 + 465 = 807

**Input**

```text
l1 = [0], l2 = [0]
```

**Output**

```text
[0]
```

**Input**

```text
l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
```

**Output**

```text
[8,9,9,9,0,0,0,1]
```

## Constraints

```text
- number_of_nodes The number of nodes in each linked list is in the range [1, 100].
- node_value 0 <= Node.val <= 9
- list_no_leading_zero It is guaranteed that the list represents a number that does not have leading zeros.
```
---

## Elementary Math

**Intuition**

This problem is essentially adding two numbers digit by digit from right to left, just like how we perform addition manually. We maintain a carry variable to handle overflow when the sum of two digits is greater than 9.

**Steps**

- Initialize a dummy head of the result list and a pointer `current` to build the list.
- Initialize a `carry` variable to 0.
- Traverse both linked lists simultaneously until both are exhausted.
- At each step, calculate the sum of the current digits and the carry.
- Create a new node with the digit value (sum % 10) and append it to the result list.
- Update the carry to (sum // 10).
- If one list is longer than the other, treat the missing digits as 0.
- After the loop, if there's still a carry, append a new node with the carry value.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy_head = ListNode(0)
    current = dummy_head
    carry = 0
    
    while l1 or l2:
        x = l1.val if l1 else 0
        y = l2.val if l2 else 0
        
        total = carry + x + y
        carry = total // 10
        
        current.next = ListNode(total % 10)
        current = current.next
        
        if l1: l1 = l1.next
        if l2: l2 = l2.next
    
    if carry > 0:
        current.next = ListNode(carry)
    
    return dummy_head.next` },
{ name: "Java", lang: "java", code: `class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode current = dummyHead;
        int carry = 0;
        
        while (l1 != null || l2 != null) {
            int x = (l1 != null) ? l1.val : 0;
            int y = (l2 != null) ? l2.val : 0;
            
            int sum = carry + x + y;
            carry = sum / 10;
            
            current.next = new ListNode(sum % 10);
            current = current.next;
            
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        
        if (carry > 0) {
            current.next = new ListNode(carry);
        }
        
        return dummyHead.next;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val);
    this.next = (next===undefined ? null : next);
}

var addTwoNumbers = function(l1, l2) {
    let dummyHead = new ListNode(0);
    let current = dummyHead;
    let carry = 0;
    
    while (l1 || l2) {
        let x = l1 ? l1.val : 0;
        let y = l2 ? l2.val : 0;
        
        let sum = carry + x + y;
        carry = Math.floor(sum / 10);
        
        current.next = new ListNode(sum % 10);
        current = current.next;
        
        if (l1) l1 = l1.next;
        if (l2) l2 = l2.next;
    }
    
    if (carry > 0) {
        current.next = new ListNode(carry);
    }
    
    return dummyHead.next;
};` },
{ name: "C++", lang: "cpp", code: `#include <iostream>
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummyHead = new ListNode(0);
        ListNode* current = dummyHead;
        int carry = 0;
        
        while (l1 || l2) {
            int x = l1 ? l1->val : 0;
            int y = l2 ? l2->val : 0;
            
            int sum = carry + x + y;
            carry = sum / 10;
            
            current->next = new ListNode(sum % 10);
            current = current->next;
            
            if (l1) l1 = l1->next;
            if (l2) l2 = l2->next;
        }
        
        if (carry > 0) {
            current->next = new ListNode(carry);
        }
        
        return dummyHead->next;
    }
};` },
{ name: "Python3", lang: "python", code: `class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy_head = ListNode(0)
        current = dummy_head
        carry = 0
        
        while l1 or l2:
            x = l1.val if l1 else 0
            y = l2.val if l2 else 0
            
            total = carry + x + y
            carry = total // 10
            
            current.next = ListNode(total % 10)
            current = current.next
            
            if l1: l1 = l1.next
            if l2: l2 = l2.next
        
        if carry > 0:
            current.next = ListNode(carry)
        
        return dummy_head.next` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <stdlib.h>

struct ListNode {
    int val;
    struct ListNode *next;
};

struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {
    struct ListNode* dummyHead = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummyHead->val = 0;
    struct ListNode* current = dummyHead;
    int carry = 0;
    
    while (l1 || l2) {
        int x = l1 ? l1->val : 0;
        int y = l2 ? l2->val : 0;
        
        int sum = carry + x + y;
        carry = sum / 10;
        
        current->next = (struct ListNode*)malloc(sizeof(struct ListNode));
        current->next->val = sum % 10;
        current->next->next = NULL;
        current = current->next;
        
        if (l1) l1 = l1->next;
        if (l2) l2 = l2->next;
    }
    
    if (carry > 0) {
        current->next = (struct ListNode*)malloc(sizeof(struct ListNode));
        current->next->val = carry;
        current->next->next = NULL;
    }
    
    return dummyHead->next;
}` },
{ name: "C#", lang: "csharp", code: `public class ListNode {
    public int val;
    public ListNode next;
    public ListNode(int val=0, ListNode next=null) {
        this.val = val;
        this.next = next;
    }
}

public class Solution {
    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode current = dummyHead;
        int carry = 0;
        
        while (l1 != null || l2 != null) {
            int x = (l1 != null) ? l1.val : 0;
            int y = (l2 != null) ? l2.val : 0;
            
            int sum = carry + x + y;
            carry = sum / 10;
            
            current.next = new ListNode(sum % 10);
            current = current.next;
            
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        
        if (carry > 0) {
            current.next = new ListNode(carry);
        }
        
        return dummyHead.next;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `class ListNode {
    val: number;
    next: ListNode | null;
    constructor(val?: number, next?: ListNode | null) {
        this.val = (val===undefined ? 0 : val);
        this.next = (next===undefined ? null : next);
    }
}

function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {
    let dummyHead = new ListNode(0);
    let current = dummyHead;
    let carry = 0;
    
    while (l1 || l2) {
        let x = l1 ? l1.val : 0;
        let y = l2 ? l2.val : 0;
        
        let sum = carry + x + y;
        carry = Math.floor(sum / 10);
        
        current.next = new ListNode(sum % 10);
        current = current.next;
        
        if (l1) l1 = l1.next;
        if (l2) l2 = l2.next;
    }
    
    if (carry > 0) {
        current.next = new ListNode(carry);
    }
    
    return dummyHead.next;
}` },
{ name: "Swift", lang: "swift", code: `public class ListNode {
    public var val: Int
    public var next: ListNode?
    public init() { self.val = 0; self.next = nil; }
    public init(_ val: Int) { self.val = val; self.next = nil; }
    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }
}

class Solution {
    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {
        let dummyHead = ListNode(0)
        var current = dummyHead
        var carry = 0
        var p1 = l1
        var p2 = l2
        
        while p1 != nil || p2 != nil {
            let x = p1?.val ?? 0
            let y = p2?.val ?? 0
            
            let sum = carry + x + y
            carry = sum / 10
            
            current.next = ListNode(sum % 10)
            current = current.next!
            
            if p1 != nil { p1 = p1?.next }
            if p2 != nil { p2 = p2?.next }
        }
        
        if carry > 0 {
            current.next = ListNode(carry)
        }
        
        return dummyHead.next
    }
}` }]} />

**Complexity**

- Time: O(max(m, n)) where m and n are the lengths of l1 and l2 respectively.
- Space: O(max(m, n)) - The length of the new list is at most max(m,n) + 1.
- Notes: We only iterate through the lists once, making one pass through each. The space is for the output list which is proportional to the length of the longer input list.

---

## Recursive Approach

**Intuition**

The iterative solution can be transformed into a recursive one. By handling one digit at a time and passing the carry to the next recursive call, we can solve the problem elegantly using recursion.

**Steps**

- Define a recursive helper function that takes two nodes and a carry value.
- Base case: When both nodes are null and there's no carry, return null.
- Calculate the sum of the current digits and carry.
- Create a new node with the digit value (sum % 10).
- Make a recursive call for the next nodes with the updated carry (sum // 10).
- Return the newly created node.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    def addHelper(n1, n2, carry):
        if not n1 and not n2 and carry == 0:
            return None
        
        val1 = n1.val if n1 else 0
        val2 = n2.val if n2 else 0
        
        total = val1 + val2 + carry
        node = ListNode(total % 10)
        
        next1 = n1.next if n1 else None
        next2 = n2.next if n2 else None
        
        node.next = addHelper(next1, next2, total // 10)
        return node
    
    return addHelper(l1, l2, 0)` },
{ name: "Java", lang: "java", code: `class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        return addHelper(l1, l2, 0);
    }
    
    private ListNode addHelper(ListNode n1, ListNode n2, int carry) {
        if (n1 == null && n2 == null && carry == 0) {
            return null;
        }
        
        int val1 = (n1 != null) ? n1.val : 0;
        int val2 = (n2 != null) ? n2.val : 0;
        
        int total = val1 + val2 + carry;
        ListNode node = new ListNode(total % 10);
        
        ListNode next1 = (n1 != null) ? n1.next : null;
        ListNode next2 = (n2 != null) ? n2.next : null;
        
        node.next = addHelper(next1, next2, total / 10);
        return node;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val);
    this.next = (next===undefined ? null : next);
}

var addTwoNumbers = function(l1, l2) {
    function addHelper(n1, n2, carry) {
        if (!n1 && !n2 && carry === 0) {
            return null;
        }
        
        const val1 = n1 ? n1.val : 0;
        const val2 = n2 ? n2.val : 0;
        
        const total = val1 + val2 + carry;
        const node = new ListNode(total % 10);
        
        const next1 = n1 ? n1.next : null;
        const next2 = n2 ? n2.next : null;
        
        node.next = addHelper(next1, next2, Math.floor(total / 10));
        return node;
    }
    
    return addHelper(l1, l2, 0);
};` },
{ name: "C++", lang: "cpp", code: `#include <iostream>
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
private:
    ListNode* addHelper(ListNode* n1, ListNode* n2, int carry) {
        if (!n1 && !n2 && carry == 0) {
            return nullptr;
        }
        
        int val1 = n1 ? n1->val : 0;
        int val2 = n2 ? n2->val : 0;
        
        int total = val1 + val2 + carry;
        ListNode* node = new ListNode(total % 10);
        
        ListNode* next1 = n1 ? n1->next : nullptr;
        ListNode* next2 = n2 ? n2->next : nullptr;
        
        node->next = addHelper(next1, next2, total / 10);
        return node;
    }
    
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        return addHelper(l1, l2, 0);
    }
};` },
{ name: "Python3", lang: "python", code: `class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        def addHelper(n1, n2, carry):
            if not n1 and not n2 and carry == 0:
                return None
            
            val1 = n1.val if n1 else 0
            val2 = n2.val if n2 else 0
            
            total = val1 + val2 + carry
            node = ListNode(total % 10)
            
            next1 = n1.next if n1 else None
            next2 = n2.next if n2 else None
            
            node.next = addHelper(next1, next2, total // 10)
            return node
        
        return addHelper(l1, l2, 0)` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <stdlib.h>

struct ListNode {
    int val;
    struct ListNode *next;
};

struct ListNode* addHelper(struct ListNode* n1, struct ListNode* n2, int carry) {
    if (!n1 && !n2 && carry == 0) {
        return NULL;
    }
    
    int val1 = n1 ? n1->val : 0;
    int val2 = n2 ? n2->val : 0;
    
    int total = val1 + val2 + carry;
    struct ListNode* node = (struct ListNode*)malloc(sizeof(struct ListNode));
    node->val = total % 10;
    
    struct ListNode* next1 = n1 ? n1->next : NULL;
    struct ListNode* next2 = n2 ? n2->next : NULL;
    
    node->next = addHelper(next1, next2, total / 10);
    return node;
}

struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {
    return addHelper(l1, l2, 0);
}` },
{ name: "C#", lang: "csharp", code: `public class ListNode {
    public int val;
    public ListNode next;
    public ListNode(int val=0, ListNode next=null) {
        this.val = val;
        this.next = next;
    }
}

public class Solution {
    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {
        return AddHelper(l1, l2, 0);
    }
    
    private ListNode AddHelper(ListNode n1, ListNode n2, int carry) {
        if (n1 == null && n2 == null && carry == 0) {
            return null;
        }
        
        int val1 = (n1 != null) ? n1.val : 0;
        int val2 = (n2 != null) ? n2.val : 0;
        
        int total = val1 + val2 + carry;
        ListNode node = new ListNode(total % 10);
        
        ListNode next1 = (n1 != null) ? n1.next : null;
        ListNode next2 = (n2 != null) ? n2.next : null;
        
        node.next = AddHelper(next1, next2, total / 10);
        return node;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `class ListNode {
    val: number;
    next: ListNode | null;
    constructor(val?: number, next?: ListNode | null) {
        this.val = (val===undefined ? 0 : val);
        this.next = (next===undefined ? null : next);
    }
}

function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {
    function addHelper(n1: ListNode | null, n2: ListNode | null, carry: number): ListNode | null {
        if (!n1 && !n2 && carry === 0) {
            return null;
        }
        
        const val1 = n1 ? n1.val : 0;
        const val2 = n2 ? n2.val : 0;
        
        const total = val1 + val2 + carry;
        const node = new ListNode(total % 10);
        
        const next1 = n1 ? n1.next : null;
        const next2 = n2 ? n2.next : null;
        
        node.next = addHelper(next1, next2, Math.floor(total / 10));
        return node;
    }
    
    return addHelper(l1, l2, 0);
}` },
{ name: "Swift", lang: "swift", code: `public class ListNode {
    public var val: Int
    public var next: ListNode?
    public init() { self.val = 0; self.next = nil; }
    public init(_ val: Int) { self.val = val; self.next = nil; }
    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }
}

class Solution {
    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {
        return addHelper(l1, l2, 0)
    }
    
    private func addHelper(_ n1: ListNode?, _ n2: ListNode?, _ carry: Int) -> ListNode? {
        if n1 == nil && n2 == nil && carry == 0 {
            return nil
        }
        
        let val1 = n1?.val ?? 0
        let val2 = n2?.val ?? 0
        
        let total = val1 + val2 + carry
        let node = ListNode(total % 10)
        
        let next1 = n1?.next
        let next2 = n2?.next
        
        node.next = addHelper(next1, next2, total / 10)
        return node
    }
}` }]} />

**Complexity**

- Time: O(max(m, n)) where m and n are the lengths of l1 and l2 respectively.
- Space: O(max(m, n)) due to the recursive call stack. The depth of recursion is proportional to the length of the longer list.
- Notes: The recursive approach is functionally identical to the iterative one in terms of time complexity, but uses the call stack for state management instead of explicit variables.

---

## Optimized Iterative with Early Termination

**Intuition**

We can optimize the basic iterative approach by early termination when one list is exhausted and there's no carry. This eliminates unnecessary iterations when one list is much longer than the other and there's no carry to propagate.

**Steps**

- Initialize a dummy head and current pointer for the result list.
- Initialize a carry variable to 0.
- Traverse both lists while at least one is not null or carry is non-zero.
- In each iteration, compute the sum and update carry.
- Create a new node with the digit value and append it.
- Handle cases where one list is longer than the other.
- Add a final check to append a carry node if needed after both lists are exhausted.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy_head = ListNode(0)
    current = dummy_head
    carry = 0
    
    while l1 or l2 or carry:
        x = l1.val if l1 else 0
        y = l2.val if l2 else 0
        
        total = carry + x + y
        carry = total // 10
        
        current.next = ListNode(total % 10)
        current = current.next
        
        l1 = l1.next if l1 else None
        l2 = l2.next if l2 else None
    
    return dummy_head.next` },
{ name: "Java", lang: "java", code: `class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode current = dummyHead;
        int carry = 0;
        
        while (l1 != null || l2 != null || carry != 0) {
            int x = (l1 != null) ? l1.val : 0;
            int y = (l2 != null) ? l2.val : 0;
            
            int sum = carry + x + y;
            carry = sum / 10;
            
            current.next = new ListNode(sum % 10);
            current = current.next;
            
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        
        return dummyHead.next;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val);
    this.next = (next===undefined ? null : next);
}

var addTwoNumbers = function(l1, l2) {
    let dummyHead = new ListNode(0);
    let current = dummyHead;
    let carry = 0;
    
    while (l1 || l2 || carry) {
        let x = l1 ? l1.val : 0;
        let y = l2 ? l2.val : 0;
        
        let sum = carry + x + y;
        carry = Math.floor(sum / 10);
        
        current.next = new ListNode(sum % 10);
        current = current.next;
        
        l1 = l1 ? l1.next : null;
        l2 = l2 ? l2.next : null;
    }
    
    return dummyHead.next;
};` },
{ name: "C++", lang: "cpp", code: `#include <iostream>
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummyHead = new ListNode(0);
        ListNode* current = dummyHead;
        int carry = 0;
        
        while (l1 || l2 || carry) {
            int x = l1 ? l1->val : 0;
            int y = l2 ? l2->val : 0;
            
            int sum = carry + x + y;
            carry = sum / 10;
            
            current->next = new ListNode(sum % 10);
            current = current->next;
            
            l1 = l1 ? l1->next : nullptr;
            l2 = l2 ? l2->next : nullptr;
        }
        
        return dummyHead->next;
    }
};` },
{ name: "Python3", lang: "python", code: `class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy_head = ListNode(0)
        current = dummy_head
        carry = 0
        
        while l1 or l2 or carry:
            x = l1.val if l1 else 0
            y = l2.val if l2 else 0
            
            total = carry + x + y
            carry = total // 10
            
            current.next = ListNode(total % 10)
            current = current.next
            
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        
        return dummy_head.next` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <stdlib.h>

struct ListNode {
    int val;
    struct ListNode *next;
};

struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {
    struct ListNode* dummyHead = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummyHead->val = 0;
    struct ListNode* current = dummyHead;
    int carry = 0;
    
    while (l1 || l2 || carry) {
        int x = l1 ? l1->val : 0;
        int y = l2 ? l2->val : 0;
        
        int sum = carry + x + y;
        carry = sum / 10;
        
        current->next = (struct ListNode*)malloc(sizeof(struct ListNode));
        current->next->val = sum % 10;
        current->next->next = NULL;
        current = current->next;
        
        l1 = l1 ? l1->next : NULL;
        l2 = l2 ? l2->next : NULL;
    }
    
    return dummyHead->next;
}` },
{ name: "C#", lang: "csharp", code: `public class ListNode {
    public int val;
    public ListNode next;
    public ListNode(int val=0, ListNode next=null) {
        this.val = val;
        this.next = next;
    }
}

public class Solution {
    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode current = dummyHead;
        int carry = 0;
        
        while (l1 != null || l2 != null || carry != 0) {
            int x = (l1 != null) ? l1.val : 0;
            int y = (l2 != null) ? l2.val : 0;
            
            int sum = carry + x + y;
            carry = sum / 10;
            
            current.next = new ListNode(sum % 10);
            current = current.next;
            
            l1 = l1 != null ? l1.next : null;
            l2 = l2 != null ? l2.next : null;
        }
        
        return dummyHead.next;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `class ListNode {
    val: number;
    next: ListNode | null;
    constructor(val?: number, next?: ListNode | null) {
        this.val = (val===undefined ? 0 : val);
        this.next = (next===undefined ? null : next);
    }
}

function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {
    let dummyHead = new ListNode(0);
    let current = dummyHead;
    let carry = 0;
    
    while (l1 || l2 || carry) {
        let x = l1 ? l1.val : 0;
        let y = l2 ? l2.val : 0;
        
        let sum = carry + x + y;
        carry = Math.floor(sum / 10);
        
        current.next = new ListNode(sum % 10);
        current = current.next;
        
        l1 = l1 ? l1.next : null;
        l2 = l2 ? l2.next : null;
    }
    
    return dummyHead.next;
}` },
{ name: "Swift", lang: "swift", code: `public class ListNode {
    public var val: Int
    public var next: ListNode?
    public init() { self.val = 0; self.next = nil; }
    public init(_ val: Int) { self.val = val; self.next = nil; }
    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }
}

class Solution {
    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {
        let dummyHead = ListNode(0)
        var current = dummyHead
        var carry = 0
        var p1 = l1
        var p2 = l2
        
        while p1 != nil || p2 != nil || carry != 0 {
            let x = p1?.val ?? 0
            let y = p2?.val ?? 0
            
            let sum = carry + x + y
            carry = sum / 10
            
            current.next = ListNode(sum % 10)
            current = current.next!
            
            p1 = p1?.next
            p2 = p2?.next
        }
        
        return dummyHead.next
    }
}` }]} />

**Complexity**

- Time: O(max(m, n)) where m and n are the lengths of l1 and l2 respectively. In the best case where one list is much shorter and there's no carry, we might terminate early.
- Space: O(max(m, n)) for the output list which is proportional to the length of the longer input list.
- Notes: This approach is more elegant as it simplifies the loop condition and eliminates the need for a separate check for carry after the loop. It's functionally equivalent to the basic iterative approach but with cleaner code.


<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"TechArticle","headline":"LeetCode Add Two Numbers Solutions","datePublished":"2025-09-07T09:08:40.752Z","description":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a s...","keywords":"LeetCode, Add Two Numbers, Medium, Linked List, Math, Recursion, Two Pointers, Hash Map, Brute Force, Array"}).replace(/</g,'\\u003c')}
</script>

<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"Elementary Math complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(max(m, n)) where m and n are the lengths of l1 and l2 respectively.; Space: O(max(m, n)) - The length of the new list is at most max(m,n) + 1.. We only iterate through the lists once, making one pass through each. The space is for the output list which is proportional to the length of the longer input list."}},{"@type":"Question","name":"Recursive Approach complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(max(m, n)) where m and n are the lengths of l1 and l2 respectively.; Space: O(max(m, n)) due to the recursive call stack. The depth of recursion is proportional to the length of the longer list.. The recursive approach is functionally identical to the iterative one in terms of time complexity, but uses the call stack for state management instead of explicit variables."}},{"@type":"Question","name":"Optimized Iterative with Early Termination complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(max(m, n)) where m and n are the lengths of l1 and l2 respectively. In the best case where one list is much shorter and there's no carry, we might terminate early.; Space: O(max(m, n)) for the output list which is proportional to the length of the longer input list.. This approach is more elegant as it simplifies the loop condition and eliminates the need for a separate check for carry after the loop. It's functionally equivalent to the basic iterative approach but with cleaner code."}}]}).replace(/</g,'\\u003c')}
</script>
