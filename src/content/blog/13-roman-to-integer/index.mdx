---
title: "Roman to Integer"
summary: "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer."
date: "Sep 08, 2025"
tags:
  - Hash Table
  - Math
  - String
draft: false
difficulty: "Easy"
---

import CodeTabs from "@components/CodeTabs"

> **Difficulty:** Easy | **Acceptance:** 65.34% | **Paid:** No

> **Topics:** Hash Table, Math, String

- Examples
- Constraints
- [Brute Force Approach](#brute-force-approach)
- [Optimal One-Pass Approach](#optimal-one-pass-approach)
- [Reverse Iteration Approach](#reverse-iteration-approach)

## Examples

**Input**

```text
s = "III"
```

**Output**

```text
3
```

**Explanation**

III = 3.

**Input**

```text
s = "LVIII"
```

**Output**

```text
58
```

**Explanation**

L = 50, V = 5, III = 3.

**Input**

```text
s = "MCMXC" (Two rounds)
```

**Output**

```text
1990
```

**Explanation**

M = 1000, CM = 900, XC = 90.

**Input**

```text
s = "IV"
```

**Output**

```text
4
```

**Explanation**

IV is 4 (since I comes before V)

**Input**

```text
s = "IX"
```

**Output**

```text
9
```

**Explanation**

IX is 9 (since I comes before X)

## Constraints

```text
- 1 <= s.length <= 15
- s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').
- It is guaranteed that s is a valid roman numeral in the range [1, 3999].
```
---

## Brute Force Approach

**Intuition**

We can sum up all values directly and then correct for subtraction cases. First pass to add all normal values, then second pass to subtract 2x the smaller value for each special case (because we counted it once too many in the first pass).

**Steps**

- Iterate through the string and add the value of each character based on a lookup table.
- Then iterate again to check for the special subtraction cases and adjust the total accordingly.
- For each subtraction case, we must subtract twice the value of the smaller character (since it was already added once).

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def romanToInt(s: str) -> int:
    roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    
    # First pass: Add all values
    for char in s:
        total += roman_map[char]
    
    # Second pass: Adjust for subtraction cases
    for i in range(len(s) - 1):
        if s[i] == 'I' and (s[i+1] == 'V' or s[i+1] == 'X'):
            total -= 2
        elif s[i] == 'X' and (s[i+1] == 'L' or s[i+1] == 'C'):
            total -= 20
        elif s[i] == 'C' and (s[i+1] == 'D' or s[i+1] == 'M'):
            total -= 200
            
    return total` },
{ name: "Java", lang: "java", code: `import java.util.HashMap;
import java.util.Map;

class Solution {
    public int romanToInt(String s) {
        Map<Character, Integer> romanMap = new HashMap<>();
        romanMap.put('I', 1);
        romanMap.put('V', 5);
        romanMap.put('X', 10);
        romanMap.put('L', 50);
        romanMap.put('C', 100);
        romanMap.put('D', 500);
        romanMap.put('M', 1000);
        
        int total = 0;
        
        // First pass: Add all values
        for (char c : s.toCharArray()) {
            total += romanMap.get(c);
        }
        
        // Second pass: Adjust for subtraction cases
        for (int i = 0; i < s.length() - 1; i++) {
            if (s.charAt(i) == 'I' && (s.charAt(i+1) == 'V' || s.charAt(i+1) == 'X')) {
                total -= 2;
            } else if (s.charAt(i) == 'X' && (s.charAt(i+1) == 'L' || s.charAt(i+1) == 'C')) {
                total -= 20;
            } else if (s.charAt(i) == 'C' && (s.charAt(i+1) == 'D' || s.charAt(i+1) == 'M')) {
                total -= 200;
            }
        }
        
        return total;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `function romanToInt(s) {
    const romanMap = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 };
    let total = 0;
    
    // First pass: Add all values
    for (let char of s) {
        total += romanMap[char];
    }
    
    // Second pass: Adjust for subtraction cases
    for (let i = 0; i < s.length - 1; i++) {
        if (s[i] === 'I' && (s[i+1] === 'V' || s[i+1] === 'X')) {
            total -= 2;
        } else if (s[i] === 'X' && (s[i+1] === 'L' || s[i+1] === 'C')) {
            total -= 20;
        } else if (s[i] === 'C' && (s[i+1] === 'D' || s[i+1] === 'M')) {
            total -= 200;
        }
    }
    
    return total;
}` },
{ name: "C++", lang: "cpp", code: `#include <unordered_map>
#include <string>
using namespace std;

class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> romanMap = {{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}};
        int total = 0;
        
        // First pass: Add all values
        for (char c : s) {
            total += romanMap[c];
        }
        
        // Second pass: Adjust for subtraction cases
        for (int i = 0; i < s.length() - 1; i++) {
            if (s[i] == 'I' && (s[i+1] == 'V' || s[i+1] == 'X')) {
                total -= 2;
            } else if (s[i] == 'X' && (s[i+1] == 'L' || s[i+1] == 'C')) {
                total -= 20;
            } else if (s[i] == 'C' && (s[i+1] == 'D' || s[i+1] == 'M')) {
                total -= 200;
            }
        }
        
        return total;
    }
};` },
{ name: "Python3", lang: "python", code: `class Solution:
    def romanToInt(self, s: str) -> int:
        roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
        total = 0
        
        # First pass: Add all values
        for char in s:
            total += roman_map[char]
        
        # Second pass: Adjust for subtraction cases
        for i in range(len(s) - 1):
            if s[i] == 'I' and (s[i+1] == 'V' or s[i+1] == 'X'):
                total -= 2
            elif s[i] == 'X' and (s[i+1] == 'L' or s[i+1] == 'C'):
                total -= 20
            elif s[i] == 'C' and (s[i+1] == 'D' or s[i+1] == 'M'):
                total -= 200
                
        return total` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <string.h>

int romanCharToInt(char c) {
    switch(c) {
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
        default: return 0;
    }
}

int romanToInt(char* s) {
    int total = 0;
    int len = strlen(s);
    
    // First pass: Add all values
    for (int i = 0; i < len; i++) {
        total += romanCharToInt(s[i]);
    }
    
    // Second pass: Adjust for subtraction cases
    for (int i = 0; i < len - 1; i++) {
        if (s[i] == 'I' && (s[i+1] == 'V' || s[i+1] == 'X')) {
            total -= 2;
        } else if (s[i] == 'X' && (s[i+1] == 'L' || s[i+1] == 'C')) {
            total -= 20;
        } else if (s[i] == 'C' && (s[i+1] == 'D' || s[i+1] == 'M')) {
            total -= 200;
        }
    }
    
    return total;
}` },
{ name: "C#", lang: "csharp", code: `using System.Collections.Generic;

class Solution {
    public int RomanToInt(string s) {
        Dictionary<char, int> romanMap = new Dictionary<char, int>();
        romanMap['I'] = 1;
        romanMap['V'] = 5;
        romanMap['X'] = 10;
        romanMap['L'] = 50;
        romanMap['C'] = 100;
        romanMap['D'] = 500;
        romanMap['M'] = 1000;
        
        int total = 0;
        
        // First pass: Add all values
        foreach (char c in s) {
            total += romanMap[c];
        }
        
        // Second pass: Adjust for subtraction cases
        for (int i = 0; i < s.Length - 1; i++) {
            if (s[i] == 'I' && (s[i+1] == 'V' || s[i+1] == 'X')) {
                total -= 2;
            } else if (s[i] == 'X' && (s[i+1] == 'L' || s[i+1] == 'C')) {
                total -= 20;
            } else if (s[i] == 'C' && (s[i+1] == 'D' || s[i+1] == 'M')) {
                total -= 200;
            }
        }
        
        return total;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function romanToInt(s: string): number {
    const romanMap: { [key: string]: number } = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 };
    let total = 0;
    
    // First pass: Add all values
    for (const char of s) {
        total += romanMap[char];
    }
    
    // Second pass: Adjust for subtraction cases
    for (let i = 0; i < s.length - 1; i++) {
        if (s[i] === 'I' && (s[i+1] === 'V' || s[i+1] === 'X')) {
            total -= 2;
        } else if (s[i] === 'X' && (s[i+1] === 'L' || s[i+1] === 'C')) {
            total -= 20;
        } else if (s[i] === 'C' && (s[i+1] === 'D' || s[i+1] === 'M')) {
            total -= 200;
        }
    }
    
    return total;
}` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func romanToInt(_ s: String) -> Int {
        let romanMap: [Character: Int] = ["I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000]
        var total = 0
        
        // First pass: Add all values
        for char in s {
            total += romanMap[char]!
        }
        
        // Second pass: Adjust for subtraction cases
        let chars = Array(s)
        for i in 0..<chars.count - 1 {
            if chars[i] == "I" && (chars[i+1] == "V" || chars[i+1] == "X") {
                total -= 2
            } else if chars[i] == "X" && (chars[i+1] == "L" || chars[i+1] == "C") {
                total -= 20
            } else if chars[i] == "C" && (chars[i+1] == "D" || chars[i+1] == "M") {
                total -= 200
            }
        }
        
        return total
    }
}` }]} />

**Complexity**

- Time: O(n) where n is the length of the string, as we iterate through the string twice
- Space: O(1) as we only use a fixed-size map and a few variables

---

## Optimal One-Pass Approach

**Intuition**

Instead of two passes, we can process the string left to right in a single pass. When we encounter a character that is smaller than the next character, we subtract its value; otherwise, we add it. This directly handles the subtraction cases.

**Steps**

- Iterate through the string from left to right.
- At each step, compare the current character's value with the next character's value.
- If the current value is less than the next value, subtract the current value from the total (this handles cases like IV, IX, etc.).
- Otherwise, add the current value to the total.
- Handle the last character separately since there's no next character to compare with.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def romanToInt(s: str) -> int:
    roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    
    for i in range(len(s)):
        if i < len(s) - 1 and roman_map[s[i]] < roman_map[s[i+1]]:
            total -= roman_map[s[i]]
        else:
            total += roman_map[s[i]]
            
    return total` },
{ name: "Java", lang: "java", code: `import java.util.HashMap;
import java.util.Map;

class Solution {
    public int romanToInt(String s) {
        Map<Character, Integer> romanMap = new HashMap<>();
        romanMap.put('I', 1);
        romanMap.put('V', 5);
        romanMap.put('X', 10);
        romanMap.put('L', 50);
        romanMap.put('C', 100);
        romanMap.put('D', 500);
        romanMap.put('M', 1000);
        
        int total = 0;
        
        for (int i = 0; i < s.length(); i++) {
            if (i < s.length() - 1 && romanMap.get(s.charAt(i)) < romanMap.get(s.charAt(i+1))) {
                total -= romanMap.get(s.charAt(i));
            } else {
                total += romanMap.get(s.charAt(i));
            }
        }
        
        return total;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `function romanToInt(s) {
    const romanMap = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 };
    let total = 0;
    
    for (let i = 0; i < s.length; i++) {
        if (i < s.length - 1 && romanMap[s[i]] < romanMap[s[i+1]]) {
            total -= romanMap[s[i]];
        } else {
            total += romanMap[s[i]];
        }
    }
    
    return total;
}` },
{ name: "C++", lang: "cpp", code: `#include <unordered_map>
#include <string>
using namespace std;

class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> romanMap = {{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}};
        int total = 0;
        
        for (int i = 0; i < s.length(); i++) {
            if (i < s.length() - 1 && romanMap[s[i]] < romanMap[s[i+1]]) {
                total -= romanMap[s[i]];
            } else {
                total += romanMap[s[i]];
            }
        }
        
        return total;
    }
};` },
{ name: "Python3", lang: "python", code: `class Solution:
    def romanToInt(self, s: str) -> int:
        roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
        total = 0
        
        for i in range(len(s)):
            if i < len(s) - 1 and roman_map[s[i]] < roman_map[s[i+1]]:
                total -= roman_map[s[i]]
            else:
                total += roman_map[s[i]]
                
        return total` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <string.h>

int romanCharToInt(char c) {
    switch(c) {
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
        default: return 0;
    }
}

int romanToInt(char* s) {
    int total = 0;
    int len = strlen(s);
    
    for (int i = 0; i < len; i++) {
        if (i < len - 1 && romanCharToInt(s[i]) < romanCharToInt(s[i+1])) {
            total -= romanCharToInt(s[i]);
        } else {
            total += romanCharToInt(s[i]);
        }
    }
    
    return total;
}` },
{ name: "C#", lang: "csharp", code: `using System.Collections.Generic;

class Solution {
    public int RomanToInt(string s) {
        Dictionary<char, int> romanMap = new Dictionary<char, int>();
        romanMap['I'] = 1;
        romanMap['V'] = 5;
        romanMap['X'] = 10;
        romanMap['L'] = 50;
        romanMap['C'] = 100;
        romanMap['D'] = 500;
        romanMap['M'] = 1000;
        
        int total = 0;
        
        for (int i = 0; i < s.Length; i++) {
            if (i < s.Length - 1 && romanMap[s[i]] < romanMap[s[i+1]]) {
                total -= romanMap[s[i]];
            } else {
                total += romanMap[s[i]];
            }
        }
        
        return total;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function romanToInt(s: string): number {
    const romanMap: { [key: string]: number } = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 };
    let total = 0;
    
    for (let i = 0; i < s.length; i++) {
        if (i < s.length - 1 && romanMap[s[i]] < romanMap[s[i+1]]) {
            total -= romanMap[s[i]];
        } else {
            total += romanMap[s[i]];
        }
    }
    
    return total;
}` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func romanToInt(_ s: String) -> Int {
        let romanMap: [Character: Int] = ["I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000]
        var total = 0
        let chars = Array(s)
        
        for i in 0..<chars.count {
            if i < chars.count - 1 && romanMap[chars[i]]! < romanMap[chars[i+1]]! {
                total -= romanMap[chars[i]]!
            } else {
                total += romanMap[chars[i]]!
            }
        }
        
        return total
    }
}` }]} />

**Complexity**

- Time: O(n) where n is the length of the string, as we iterate through the string once
- Space: O(1) as we only use a fixed-size map and a few variables

---

## Reverse Iteration Approach

**Intuition**

We can iterate from right to left. When we see a character that is smaller than the previous character (the one we just processed), we subtract its value. This is another way to naturally handle subtraction cases.

**Steps**

- Start from the rightmost character and move left.
- Keep track of the value of the previously processed character.
- If the current character's value is less than the previous one, subtract it from the total.
- Otherwise, add it to the total.
- Update the previous character's value after each iteration.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def romanToInt(s: str) -> int:
    roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0
    
    for i in range(len(s) - 1, -1, -1):
        current_value = roman_map[s[i]]
        if current_value < prev_value:
            total -= current_value
        else:
            total += current_value
        prev_value = current_value
            
    return total` },
{ name: "Java", lang: "java", code: `import java.util.HashMap;
import java.util.Map;

class Solution {
    public int romanToInt(String s) {
        Map<Character, Integer> romanMap = new HashMap<>();
        romanMap.put('I', 1);
        romanMap.put('V', 5);
        romanMap.put('X', 10);
        romanMap.put('L', 50);
        romanMap.put('C', 100);
        romanMap.put('D', 500);
        romanMap.put('M', 1000);
        
        int total = 0;
        int prevValue = 0;
        
        for (int i = s.length() - 1; i >= 0; i--) {
            int currentValue = romanMap.get(s.charAt(i));
            if (currentValue < prevValue) {
                total -= currentValue;
            } else {
                total += currentValue;
            }
            prevValue = currentValue;
        }
        
        return total;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `function romanToInt(s) {
    const romanMap = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 };
    let total = 0;
    let prevValue = 0;
    
    for (let i = s.length - 1; i >= 0; i--) {
        const currentValue = romanMap[s[i]];
        if (currentValue < prevValue) {
            total -= currentValue;
        } else {
            total += currentValue;
        }
        prevValue = currentValue;
    }
    
    return total;
}` },
{ name: "C++", lang: "cpp", code: `#include <unordered_map>
#include <string>
using namespace std;

class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> romanMap = {{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}};
        int total = 0;
        int prevValue = 0;
        
        for (int i = s.length() - 1; i >= 0; i--) {
            int currentValue = romanMap[s[i]];
            if (currentValue < prevValue) {
                total -= currentValue;
            } else {
                total += currentValue;
            }
            prevValue = currentValue;
        }
        
        return total;
    }
};` },
{ name: "Python3", lang: "python", code: `class Solution:
    def romanToInt(self, s: str) -> int:
        roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
        total = 0
        prev_value = 0
        
        for i in range(len(s) - 1, -1, -1):
            current_value = roman_map[s[i]]
            if current_value < prev_value:
                total -= current_value
            else:
                total += current_value
            prev_value = current_value
                
        return total` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <string.h>

int romanCharToInt(char c) {
    switch(c) {
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
        default: return 0;
    }
}

int romanToInt(char* s) {
    int total = 0;
    int prevValue = 0;
    int len = strlen(s);
    
    for (int i = len - 1; i >= 0; i--) {
        int currentValue = romanCharToInt(s[i]);
        if (currentValue < prevValue) {
            total -= currentValue;
        } else {
            total += currentValue;
        }
        prevValue = currentValue;
    }
    
    return total;
}` },
{ name: "C#", lang: "csharp", code: `using System.Collections.Generic;

class Solution {
    public int RomanToInt(string s) {
        Dictionary<char, int> romanMap = new Dictionary<char, int>();
        romanMap['I'] = 1;
        romanMap['V'] = 5;
        romanMap['X'] = 10;
        romanMap['L'] = 50;
        romanMap['C'] = 100;
        romanMap['D'] = 500;
        romanMap['M'] = 1000;
        
        int total = 0;
        int prevValue = 0;
        
        for (int i = s.Length - 1; i >= 0; i--) {
            int currentValue = romanMap[s[i]];
            if (currentValue < prevValue) {
                total -= currentValue;
            } else {
                total += currentValue;
            }
            prevValue = currentValue;
        }
        
        return total;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function romanToInt(s: string): number {
    const romanMap: { [key: string]: number } = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 };
    let total = 0;
    let prevValue = 0;
    
    for (let i = s.length - 1; i >= 0; i--) {
        const currentValue = romanMap[s[i]];
        if (currentValue < prevValue) {
            total -= currentValue;
        } else {
            total += currentValue;
        }
        prevValue = currentValue;
    }
    
    return total;
}` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func romanToInt(_ s: String) -> Int {
        let romanMap: [Character: Int] = ["I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000]
        var total = 0
        var prevValue = 0
        let chars = Array(s)
        
        for i in stride(from: chars.count - 1, through: 0, by: -1) {
            let currentValue = romanMap[chars[i]]!
            if currentValue < prevValue {
                total -= currentValue
            } else {
                total += currentValue
            }
            prevValue = currentValue
        }
        
        return total
    }
}` }]} />

**Complexity**

- Time: O(n) where n is the length of the string, as we iterate through the string once
- Space: O(1) as we only use a fixed-size map and a few variables


<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"TechArticle","headline":"LeetCode Roman to Integer Solutions","datePublished":"2025-09-08T21:03:01.254Z","description":"Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. For example, 2 is written as II in Roman numeral, just two ones added toge...","keywords":"LeetCode, Roman to Integer, Easy, Hash Table, Math, String, Two Pointers, Hash Map, Brute Force, Array"}).replace(/</g,'\\u003c')}
</script>

<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"Brute Force Approach complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n) where n is the length of the string, as we iterate through the string twice; Space: O(1) as we only use a fixed-size map and a few variables. "}},{"@type":"Question","name":"Optimal One-Pass Approach complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n) where n is the length of the string, as we iterate through the string once; Space: O(1) as we only use a fixed-size map and a few variables. "}},{"@type":"Question","name":"Reverse Iteration Approach complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n) where n is the length of the string, as we iterate through the string once; Space: O(1) as we only use a fixed-size map and a few variables. "}}]}).replace(/</g,'\\u003c')}
</script>
