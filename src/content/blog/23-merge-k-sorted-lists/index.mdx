---
title: "Merge k Sorted Lists"
summary: "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it."
date: "Sep 12, 2025"
tags:
  - Linked List
  - Divide and Conquer
  - Heap (Priority Queue)
  - Merge Sort
draft: false
difficulty: "Hard"
---

import CodeTabs from "@components/CodeTabs"

> **Difficulty:** Hard | **Acceptance:** 57.48% | **Paid:** No

> **Topics:** Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort

- Examples
- Constraints
- [Brute Force - Collect and Sort](#brute-force-collect-and-sort)
- [Optimal - Min-Heap/Priority Queue](#optimal-min-heap-priority-queue)
- [Divide and Conquer (Pairwise Merging)](#divide-and-conquer-pairwise-merging)

## Examples

**Input**

```text
lists = [[1,4,5],[1,3,4],[2,6]]
```

**Output**

```text
[1,1,2,3,4,4,5,6]
```

**Explanation**

The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6

**Input**

```text
lists = []
```

**Output**

```text
[]
```

**Input**

```text
lists = [[]]
```

**Output**

```text
[]
```

## Constraints

```text
- k == lists.length
- 0 <= k <= 10^4
- 0 <= lists[i].length <= 500
- -10^4 <= lists[i][j] <= 10^4
- lists[i] is sorted in ascending order.
- The sum of lists[i].length will not exceed 10^4.
```
---

## Brute Force - Collect and Sort

**Intuition**

If we collect all elements from the k lists into an array, we can then sort it and recreate the merged list.

**Steps**

- Initialize an empty list to collect all node values.
- Traverse each linked list and add all node values to the collection.
- Sort the collection.
- Rebuild a new sorted linked list from the sorted values.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
def mergeKLists_bruteforce(lists):
    if not lists:
        return None
    values = []
    for head in lists:
        current = head
        while current:
            values.append(current.val)
            current = current.next
    values.sort()
    dummy = ListNode(0)
    current = dummy
    for val in values:
        current.next = ListNode(val)
        current = current.next
    return dummy.next` },
{ name: "Java", lang: "java", code: `import java.util.*;
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        List<Integer> values = new ArrayList<>();
        for (ListNode head : lists) {
            ListNode current = head;
            while (current != null) {
                values.add(current.val);
                current = current.next;
            }
        }
        Collections.sort(values);
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        for (int val : values) {
            current.next = new ListNode(val);
            current = current.next;
        }
        return dummy.next;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}
var mergeKLists = function(lists) {
    let values = [];
    for (let head of lists) {
        let current = head;
        while (current) {
            values.push(current.val);
            current = current.next;
        }
    }
    values.sort((a, b) => a - b);
    let dummy = new ListNode(0);
    let current = dummy;
    for (let val of values) {
        current.next = new ListNode(val);
        current = current.next;
    }
    return dummy.next;
};` },
{ name: "C++", lang: "cpp", code: `#include <vector>
#include <algorithm>
using namespace std;
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        vector<int> values;
        for (ListNode* head : lists) {
            ListNode* current = head;
            while (current) {
                values.push_back(current->val);
                current = current->next;
            }
        }
        sort(values.begin(), values.end());
        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;
        for (int val : values) {
            current->next = new ListNode(val);
            current = current->next;
        }
        return dummy->next;
    }
};` },
{ name: "Python3", lang: "python", code: `from typing import List, Optional
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        if not lists:
            return None
        values = []
        for head in lists:
            current = head
            while current:
                values.append(current.val)
                current = current.next
        values.sort()
        dummy = ListNode(0)
        current = dummy
        for val in values:
            current.next = ListNode(val)
            current = current.next
        return dummy.next` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <stdlib.h>
struct ListNode {
    int val;
    struct ListNode *next;
};
int compareInts(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}
struct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {
    if (listsSize == 0) return NULL;
    int* values = (int*)malloc(10000 * sizeof(int));
    int count = 0;
    for (int i = 0; i < listsSize; i++) {
        struct ListNode* current = lists[i];
        while (current) {
            values[count++] = current->val;
            current = current->next;
        }
    }
    if (count == 0) {
        free(values);
        return NULL;
    }
    qsort(values, count, sizeof(int), compareInts);
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummy->val = 0;
    struct ListNode* current = dummy;
    for (int i = 0; i < count; i++) {
        struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
        newNode->val = values[i];
        newNode->next = NULL;
        current->next = newNode;
        current = current->next;
    }
    free(values);
    struct ListNode* head = dummy->next;
    free(dummy);
    return head;
}` },
{ name: "C#", lang: "csharp", code: `using System;
using System.Collections.Generic;
public class ListNode {
    public int val;
    public ListNode next;
    public ListNode(int val=0, ListNode next=null) {
        this.val = val;
        this.next = next;
    }
}
public class Solution {
    public ListNode MergeKLists(ListNode[] lists) {
        List<int> values = new List<int>();
        foreach (ListNode head in lists) {
            ListNode current = head;
            while (current != null) {
                values.Add(current.val);
                current = current.next;
            }
        }
        values.Sort();
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        foreach (int val in values) {
            current.next = new ListNode(val);
            current = current.next;
        }
        return dummy.next;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `class ListNode {
    val: number
    next: ListNode | null
    constructor(val?: number, next?: ListNode | null) {
        this.val = (val===undefined ? 0 : val)
        this.next = (next===undefined ? null : next)
    }
}
function mergeKLists(lists: Array<ListNode | null>): ListNode | null {
    let values: number[] = [];
    for (let head of lists) {
        let current = head;
        while (current) {
            values.push(current.val);
            current = current.next;
        }
    }
    values.sort((a, b) => a - b);
    let dummy = new ListNode(0);
    let current = dummy;
    for (let val of values) {
        current.next = new ListNode(val);
        current = current.next;
    }
    return dummy.next;
};` },
{ name: "Swift", lang: "swift", code: `public class ListNode {
    public var val: Int
    public var next: ListNode?
    public init() { self.val = 0; self.next = nil; }
    public init(_ val: Int) { self.val = val; self.next = nil; }
    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }
}
class Solution {
    func mergeKLists(_ lists: [ListNode?]) -> ListNode? {
        var values: [Int] = []
        for list in lists {
            var current = list
            while current != nil {
                values.append(current!.val)
                current = current?.next
            }
        }
        values.sort()
        let dummy = ListNode(0)
        var current: ListNode? = dummy
        for val in values {
            current?.next = ListNode(val)
            current = current?.next
        }
        return dummy.next
    }
}` }]} />

**Complexity**

- Time: O(N log N) where N is the total number of nodes across all lists. This is due to the sorting step.
- Space: O(N) for storing all node values and creating the new list.
- Notes: This approach is straightforward but not optimal. It doesn't leverage the sorted nature of the individual lists.

---

## Optimal - Min-Heap/Priority Queue

**Intuition**

Since each list is sorted, we can efficiently find the smallest element among all heads using a min-heap.

**Steps**

- Use a min-heap (priority queue) to keep track of the current smallest elements from each list.
- Initially, push the head of each non-empty list into the heap.
- Repeatedly extract the minimum element from the heap and append it to the result.
- If the extracted node has a next node, push the next node into the heap.
- Continue until the heap is empty.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `import heapq
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
class Solution:
    def mergeKLists(self, lists):
        # Initialize heap with the head of each list
        heap = []
        for i, head in enumerate(lists):
            if head:
                heapq.heappush(heap, (head.val, i, head))
        
        # Dummy node to build the result
        dummy = ListNode(0)
        current = dummy
        
        # Process the heap
        while heap:
            val, i, node = heapq.heappop(heap)
            current.next = node
            current = current.next
            
            # If there's a next node, push it to the heap
            if node.next:
                heapq.heappush(heap, (node.next.val, i, node.next))
        
        return dummy.next` },
{ name: "Java", lang: "java", code: `import java.util.*;
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> heap = new PriorityQueue<>((a, b) -> a.val - b.val);
        
        for (ListNode head : lists) {
            if (head != null) {
                heap.offer(head);
            }
        }
        
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        
        while (!heap.isEmpty()) {
            ListNode node = heap.poll();
            current.next = node;
            current = current.next;
            
            if (node.next != null) {
                heap.offer(node.next);
            }
        }
        
        return dummy.next;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}
var mergeKLists = function(lists) {
    const heap = new MinPriorityQueue({ priority: x => x.val });
    
    for (let head of lists) {
        if (head) {
            heap.enqueue(head);
        }
    }
    
    const dummy = new ListNode(0);
    let current = dummy;
    
    while (!heap.isEmpty()) {
        const node = heap.dequeue().element;
        current.next = node;
        current = current.next;
        
        if (node.next) {
            heap.enqueue(node.next);
        }
    }
    
    return dummy.next;
};` },
{ name: "C++", lang: "cpp", code: `#include <vector>
#include <queue>
using namespace std;
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> heap(cmp);
        
        for (ListNode* head : lists) {
            if (head) {
                heap.push(head);
            }
        }
        
        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;
        
        while (!heap.empty()) {
            ListNode* node = heap.top();
            heap.pop();
            current->next = node;
            current = current->next;
            
            if (node->next) {
                heap.push(node->next);
            }
        }
        
        return dummy->next;
    }
};` },
{ name: "Python3", lang: "python", code: `import heapq
from typing import List, Optional
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        # To handle duplicate values, we also store the index of the list
        heap = []
        for i, head in enumerate(lists):
            if head:
                heapq.heappush(heap, (head.val, i, head))
        
        dummy = ListNode(0)
        current = dummy
        
        while heap:
            val, i, node = heapq.heappop(heap)
            current.next = node
            current = current.next
            
            if node.next:
                heapq.heappush(heap, (node.next.val, i, node.next))
        
        return dummy.next` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <stdlib.h>
struct ListNode {
    int val;
    struct ListNode *next;
};
// Simple array-based min-heap implementation
struct MinHeap {
    struct ListNode** data;
    int size;
    int capacity;
};
struct MinHeap* createMinHeap(int capacity) {
    struct MinHeap* heap = (struct MinHeap*)malloc(sizeof(struct MinHeap));
    heap->data = (struct ListNode**)malloc(capacity * sizeof(struct ListNode*));
    heap->size = 0;
    heap->capacity = capacity;
    return heap;
}
void swap(struct ListNode** a, struct ListNode** b) {
    struct ListNode* temp = *a;
    *a = *b;
    *b = temp;
}
void heapifyUp(struct MinHeap* heap, int index) {
    while (index > 0) {
        int parent = (index - 1) / 2;
        if (heap->data[parent]->val <= heap->data[index]->val) break;
        swap(&heap->data[parent], &heap->data[index]);
        index = parent;
    }
}
void heapifyDown(struct MinHeap* heap, int index) {
    while (1) {
        int smallest = index;
        int left = 2 * index + 1;
        int right = 2 * index + 2;
        
        if (left < heap->size && heap->data[left]->val < heap->data[smallest]->val)
            smallest = left;
        if (right < heap->size && heap->data[right]->val < heap->data[smallest]->val)
            smallest = right;
        
        if (smallest == index) break;
        swap(&heap->data[index], &heap->data[smallest]);
        index = smallest;
    }
}
void push(struct MinHeap* heap, struct ListNode* node) {
    if (heap->size >= heap->capacity) return;
    heap->data[heap->size] = node;
    heapifyUp(heap, heap->size);
    heap->size++;
}
struct ListNode* pop(struct MinHeap* heap) {
    if (heap->size <= 0) return NULL;
    struct ListNode* root = heap->data[0];
    heap->data[0] = heap->data[--heap->size];
    if (heap->size > 0) heapifyDown(heap, 0);
    return root;
}
struct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {
    struct MinHeap* heap = createMinHeap(10000);
    
    for (int i = 0; i < listsSize; i++) {
        if (lists[i] != NULL) {
            push(heap, lists[i]);
        }
    }
    
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummy->val = 0;
    struct ListNode* current = dummy;
    
    while (heap->size > 0) {
        struct ListNode* node = pop(heap);
        current->next = node;
        current = current->next;
        
        if (node->next != NULL) {
            push(heap, node->next);
        }
    }
    
    struct ListNode* result = dummy->next;
    free(dummy);
    free(heap->data);
    free(heap);
    return result;
}` },
{ name: "C#", lang: "csharp", code: `using System;
using System.Collections.Generic;
public class ListNode {
    public int val;
    public ListNode next;
    public ListNode(int val=0, ListNode next=null) {
        this.val = val;
        this.next = next;
    }
}
public class Solution {
    public ListNode MergeKLists(ListNode[] lists) {
        var heap = new PriorityQueue<ListNode, int>();
        
        foreach (var head in lists) {
            if (head != null) {
                heap.Enqueue(head, head.val);
            }
        }
        
        var dummy = new ListNode(0);
        var current = dummy;
        
        while (heap.Count > 0) {
            var node = heap.Dequeue();
            current.next = node;
            current = current.next;
            
            if (node.next != null) {
                heap.Enqueue(node.next, node.next.val);
            }
        }
        
        return dummy.next;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `class ListNode {
    val: number
    next: ListNode | null
    constructor(val?: number, next?: ListNode | null) {
        this.val = (val===undefined ? 0 : val)
        this.next = (next===undefined ? null : next)
    }
}
function mergeKLists(lists: Array<ListNode | null>): ListNode | null {
    const heap = new MinPriorityQueue({ priority: (x: ListNode) => x.val });
    
    for (const head of lists) {
        if (head) {
            heap.enqueue(head);
        }
    }
    
    const dummy = new ListNode(0);
    let current: ListNode | null = dummy;
    
    while (!heap.isEmpty()) {
        const node = heap.dequeue().element;
        current!.next = node;
        current = current!.next;
        
        if (node.next) {
            heap.enqueue(node.next);
        }
    }
    
    return dummy.next;
};` },
{ name: "Swift", lang: "swift", code: `public class ListNode {
    public var val: Int
    public var next: ListNode?
    public init() { self.val = 0; self.next = nil; }
    public init(_ val: Int) { self.val = val; self.next = nil; }
    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }
}
class Solution {
    func mergeKLists(_ lists: [ListNode?]) -> ListNode? {
        var heap: [ListNode] = []
        
        for head in lists {
            if let head = head {
                heap.append(head)
                heapifyUp(&heap)
            }
        }
        
        let dummy = ListNode(0)
        var current: ListNode? = dummy
        
        while !heap.isEmpty {
            let node = pop(&heap)
            current?.next = node
            current = current?.next
            
            if let next = node.next {
                heap.append(next)
                heapifyUp(&heap)
            }
        }
        
        return dummy.next
    }
    
    private func heapifyUp(_ heap: inout [ListNode]) {
        var index = heap.count - 1
        while index > 0 {
            let parent = (index - 1) / 2
            if heap[parent].val <= heap[index].val { break }
            heap.swapAt(parent, index)
            index = parent
        }
    }
    
    private func heapifyDown(_ heap: inout [ListNode]) {
        var index = 0
        while true {
            var smallest = index
            let left = 2 * index + 1
            let right = 2 * index + 2
            
            if left < heap.count && heap[left].val < heap[smallest].val {
                smallest = left
            }
            if right < heap.count && heap[right].val < heap[smallest].val {
                smallest = right
            }
            
            if smallest == index { break }
            heap.swapAt(index, smallest)
            index = smallest
        }
    }
    
    private func pop(_ heap: inout [ListNode]) -> ListNode {
        let root = heap[0]
        heap[0] = heap.removeLast()
        if !heap.isEmpty {
            heapifyDown(&heap)
        }
        return root
    }
}` }]} />

**Complexity**

- Time: O(N log k) where N is the total number of nodes across all lists and k is the number of lists. Each insertion and extraction from the heap takes O(log k) time, and we do this N times.
- Space: O(k) for the heap which can hold at most one node from each of the k lists.
- Notes: This is the optimal approach in terms of time complexity. It efficiently maintains the minimum element at each step. This approach is particularly efficient when k is much smaller than N.

---

## Divide and Conquer (Pairwise Merging)

**Intuition**

We can reduce the problem by merging pairs of lists iteratively until we have a single list.

**Steps**

- If the list of lists is empty, return null.
- If there's only one list, return it.
- While there's more than one list, iterate through the list and merge pairs of adjacent lists.
- Replace the pairs with their merged result.
- Continue this process until only one list remains.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
class Solution:
    def mergeTwoLists(self, list1, list2):
        dummy = ListNode(0)
        current = dummy
        
        while list1 and list2:
            if list1.val <= list2.val:
                current.next = list1
                list1 = list1.next
            else:
                current.next = list2
                list2 = list2.next
            current = current.next
        
        current.next = list1 if list1 else list2
        return dummy.next
    
    def mergeKLists(self, lists):
        if not lists:
            return None
        
        while len(lists) > 1:
            merged_lists = []
            for i in range(0, len(lists), 2):
                list1 = lists[i]
                list2 = lists[i+1] if i+1 < len(lists) else None
                merged_lists.append(self.mergeTwoLists(list1, list2))
            lists = merged_lists
        
        return lists[0] if lists else None` },
{ name: "Java", lang: "java", code: `class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        
        while (list1 != null && list2 != null) {
            if (list1.val <= list2.val) {
                current.next = list1;
                list1 = list1.next;
            } else {
                current.next = list2;
                list2 = list2.next;
            }
            current = current.next;
        }
        
        current.next = (list1 != null) ? list1 : list2;
        return dummy.next;
    }
    
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) return null;
        
        java.util.List<ListNode> currentLists = new java.util.ArrayList<>();
        for (ListNode head : lists) {
            currentLists.add(head);
        }
        
        while (currentLists.size() > 1) {
            java.util.List<ListNode> mergedLists = new java.util.ArrayList<>();
            for (int i = 0; i < currentLists.size(); i += 2) {
                ListNode list1 = currentLists.get(i);
                ListNode list2 = (i + 1 < currentLists.size()) ? currentLists.get(i + 1) : null;
                mergedLists.add(mergeTwoLists(list1, list2));
            }
            currentLists = mergedLists;
        }
        
        return currentLists.isEmpty() ? null : currentLists.get(0);
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}
var mergeKLists = function(lists) {
    if (lists.length === 0) return null;
    
    const mergeTwoLists = (list1, list2) => {
        let dummy = new ListNode(0);
        let current = dummy;
        
        while (list1 && list2) {
            if (list1.val <= list2.val) {
                current.next = list1;
                list1 = list1.next;
            } else {
                current.next = list2;
                list2 = list2.next;
            }
            current = current.next;
        }
        
        current.next = list1 || list2;
        return dummy.next;
    };
    
    while (lists.length > 1) {
        let mergedLists = [];
        for (let i = 0; i < lists.length; i += 2) {
            let list1 = lists[i];
            let list2 = (i + 1 < lists.length) ? lists[i + 1] : null;
            mergedLists.push(mergeTwoLists(list1, list2));
        }
        lists = mergedLists;
    }
    
    return lists[0] || null;
};` },
{ name: "C++", lang: "cpp", code: `#include <vector>
using namespace std;
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;
        
        while (list1 && list2) {
            if (list1->val <= list2->val) {
                current->next = list1;
                list1 = list1->next;
            } else {
                current->next = list2;
                list2 = list2->next;
            }
            current = current->next;
        }
        
        current->next = list1 ? list1 : list2;
        return dummy->next;
    }
    
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty()) return nullptr;
        
        while (lists.size() > 1) {
            vector<ListNode*> mergedLists;
            for (int i = 0; i < lists.size(); i += 2) {
                ListNode* list1 = lists[i];
                ListNode* list2 = (i + 1 < lists.size()) ? lists[i + 1] : nullptr;
                mergedLists.push_back(mergeTwoLists(list1, list2));
            }
            lists = mergedLists;
        }
        
        return lists.empty() ? nullptr : lists[0];
    }
};` },
{ name: "Python3", lang: "python", code: `from typing import List, Optional
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        current = dummy
        
        while list1 and list2:
            if list1.val <= list2.val:
                current.next = list1
                list1 = list1.next
            else:
                current.next = list2
                list2 = list2.next
            current = current.next
        
        current.next = list1 if list1 else list2
        return dummy.next
    
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        if not lists:
            return None
        
        while len(lists) > 1:
            merged_lists = []
            for i in range(0, len(lists), 2):
                list1 = lists[i]
                list2 = lists[i+1] if i+1 < len(lists) else None
                merged_lists.append(self.mergeTwoLists(list1, list2))
            lists = merged_lists
        
        return lists[0] if lists else None` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <stdlib.h>
struct ListNode {
    int val;
    struct ListNode *next;
};
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    struct ListNode* dummy = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummy->val = 0;
    struct ListNode* current = dummy;
    
    while (list1 && list2) {
        if (list1->val <= list2->val) {
            current->next = list1;
            list1 = list1->next;
        } else {
            current->next = list2;
            list2 = list2->next;
        }
        current = current->next;
    }
    
    current->next = list1 ? list1 : list2;
    struct ListNode* head = dummy->next;
    free(dummy);
    return head;
}
struct ListNode** mergeListsInPairs(struct ListNode** lists, int size, int* newSize) {
    int capacity = (size + 1) / 2;
    struct ListNode** merged = (struct ListNode**)malloc(capacity * sizeof(struct ListNode*));
    *newSize = 0;
    
    for (int i = 0; i < size; i += 2) {
        struct ListNode* list1 = lists[i];
        struct ListNode* list2 = (i + 1 < size) ? lists[i + 1] : NULL;
        merged[(*newSize)++] = mergeTwoLists(list1, list2);
    }
    
    free(lists);
    return merged;
}
struct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {
    if (listsSize == 0) return NULL;
    
    while (listsSize > 1) {
        lists = mergeListsInPairs(lists, listsSize, &listsSize);
    }
    
    return lists[0];
}` },
{ name: "C#", lang: "csharp", code: `using System;
using System.Collections.Generic;
public class ListNode {
    public int val;
    public ListNode next;
    public ListNode(int val=0, ListNode next=null) {
        this.val = val;
        this.next = next;
    }
}
public class Solution {
    public ListNode MergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        
        while (list1 != null && list2 != null) {
            if (list1.val <= list2.val) {
                current.next = list1;
                list1 = list1.next;
            } else {
                current.next = list2;
                list2 = list2.next;
            }
            current = current.next;
        }
        
        current.next = list1 ?? list2;
        return dummy.next;
    }
    
    public ListNode MergeKLists(ListNode[] lists) {
        if (lists.Length == 0) return null;
        
        var currentLists = new List<ListNode>(lists);
        
        while (currentLists.Count > 1) {
            var mergedLists = new List<ListNode>();
            for (int i = 0; i < currentLists.Count; i += 2) {
                ListNode list1 = currentLists[i];
                ListNode list2 = (i + 1 < currentLists.Count) ? currentLists[i + 1] : null;
                mergedLists.Add(MergeTwoLists(list1, list2));
            }
            currentLists = mergedLists;
        }
        
        return currentLists.Count > 0 ? currentLists[0] : null;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `class ListNode {
    val: number
    next: ListNode | null
    constructor(val?: number, next?: ListNode | null) {
        this.val = (val===undefined ? 0 : val)
        this.next = (next===undefined ? null : next)
    }
}
function mergeKLists(lists: Array<ListNode | null>): ListNode | null {
    if (lists.length === 0) return null;
    
    const mergeTwoLists = (list1: ListNode | null, list2: ListNode | null): ListNode | null => {
        let dummy = new ListNode(0);
        let current: ListNode | null = dummy;
        
        while (list1 && list2) {
            if (list1.val <= list2.val) {
                current.next = list1;
                list1 = list1.next;
            } else {
                current.next = list2;
                list2 = list2.next;
            }
            current = current.next;
        }
        
        current!.next = list1 || list2;
        return dummy.next;
    };
    
    while (lists.length > 1) {
        let mergedLists: Array<ListNode | null> = [];
        for (let i = 0; i < lists.length; i += 2) {
            let list1 = lists[i];
            let list2 = (i + 1 < lists.length) ? lists[i + 1] : null;
            mergedLists.push(mergeTwoLists(list1, list2));
        }
        lists = mergedLists;
    }
    
    return lists[0] || null;
};` },
{ name: "Swift", lang: "swift", code: `public class ListNode {
    public var val: Int
    public var next: ListNode?
    public init() { self.val = 0; self.next = nil; }
    public init(_ val: Int) { self.val = val; self.next = nil; }
    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }
}
class Solution {
    func mergeTwoLists(_ list1: ListNode?, _ list2: ListNode?) -> ListNode? {
        let dummy = ListNode(0)
        var current: ListNode? = dummy
        var l1 = list1
        var l2 = list2
        
        while l1 != nil && l2 != nil {
            if l1!.val <= l2!.val {
                current?.next = l1
                l1 = l1?.next
            } else {
                current?.next = l2
                l2 = l2?.next
            }
            current = current?.next
        }
        
        current?.next = l1 ?? l2
        return dummy.next
    }
    
    func mergeKLists(_ lists: [ListNode?]) -> ListNode? {
        if lists.isEmpty { return nil }
        
        var currentLists = lists
        
        while currentLists.count > 1 {
            var mergedLists: [ListNode?] = []
            for i in stride(from: 0, to: currentLists.count, by: 2) {
                let list1 = currentLists[i]
                let list2 = (i + 1 < currentLists.count) ? currentLists[i + 1] : nil
                mergedLists.append(mergeTwoLists(list1, list2))
            }
            currentLists = mergedLists
        }
        
        return currentLists.first ?? nil
    }
}` }]} />

**Complexity**

- Time: O(N log k) where N is the total number of nodes and k is the number of lists. We have log k levels of merging, and at each level, we process all N nodes.
- Space: O(1) if we don't count the space used by the input. The merging process reuses existing nodes.
- Notes: This approach mirrors merge sort. It's elegant and has the same time complexity as the heap-based approach but with constant space. It also has good cache performance due to sequential access patterns.


<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"TechArticle","headline":"LeetCode Merge k Sorted Lists Solutions","datePublished":"2025-09-12T03:03:13.709Z","description":"You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and ret...","keywords":"LeetCode, Merge k Sorted Lists, Hard, Linked List, Divide and Conquer, Heap (Priority Queue), Merge Sort, Two Pointers, Hash Map, Brute Force, Array"}).replace(/</g,'\\u003c')}
</script>

<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"Brute Force - Collect and Sort complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(N log N) where N is the total number of nodes across all lists. This is due to the sorting step.; Space: O(N) for storing all node values and creating the new list.. This approach is straightforward but not optimal. It doesn't leverage the sorted nature of the individual lists."}},{"@type":"Question","name":"Optimal - Min-Heap/Priority Queue complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(N log k) where N is the total number of nodes across all lists and k is the number of lists. Each insertion and extraction from the heap takes O(log k) time, and we do this N times.; Space: O(k) for the heap which can hold at most one node from each of the k lists.. This is the optimal approach in terms of time complexity. It efficiently maintains the minimum element at each step. This approach is particularly efficient when k is much smaller than N."}},{"@type":"Question","name":"Divide and Conquer (Pairwise Merging) complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(N log k) where N is the total number of nodes and k is the number of lists. We have log k levels of merging, and at each level, we process all N nodes.; Space: O(1) if we don't count the space used by the input. The merging process reuses existing nodes.. This approach mirrors merge sort. It's elegant and has the same time complexity as the heap-based approach but with constant space. It also has good cache performance due to sequential access patterns."}}]}).replace(/</g,'\\u003c')}
</script>
