---
title: "Find the Index of the First Occurrence in a String"
summary: "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack."
date: "Sep 18, 2025"
tags:
  - Two Pointers
  - String
  - String Matching
draft: false
difficulty: "Easy"
---

import CodeTabs from "@components/CodeTabs"

> **Difficulty:** Easy | **Acceptance:** 45.38% | **Paid:** No

> **Topics:** Two Pointers, String, String Matching

- Examples
- Constraints
- [Brute Force / Naive String Matching](#brute-force-naive-string-matching)
- [KMP Algorithm (Knuth-Morris-Pratt)](#kmp-algorithm-knuth-morris-pratt)
- [Rabin-Karp Algorithm](#rabin-karp-algorithm)

## Examples

**Input**

```text
haystack = "sadbutsad", needle = "sad"
```

**Output**

```text
0
```

**Explanation**

"sad" occurs at index 0 and 6. The first occurrence is at index 0, so we return 0.

**Input**

```text
haystack = "leetcode", needle = "leeto"
```

**Output**

```text
-1
```

**Explanation**

"leeto" did not occur in "leetcode", so we return -1.

## Constraints

```text
- 1 <= haystack.length, needle.length <= 10^4
- haystack and needle consist of only lowercase English characters.
```
---

## Brute Force / Naive String Matching

**Intuition**

A straightforward approach would be to check every possible position in the haystack to see if the needle occurs at that position. We can do this by iterating through the haystack and, at each position, comparing the substring with the needle.

**Steps**

- Iterate through the haystack from index 0 to len(haystack) - len(needle). This ensures we don't go out of bounds.
- At each position i, compare the substring haystack[i:i+len(needle)] with the needle.
- If a match is found, return the current index i. If the loop completes without finding a match, return -1.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def strStr(haystack: str, needle: str) -> int:
    if not needle:
        return 0
    
    needle_len = len(needle)
    haystack_len = len(haystack)
    
    for i in range(haystack_len - needle_len + 1):
        # Check if substring matches needle
        if haystack[i:i + needle_len] == needle:
            return i
    
    return -1` },
{ name: "Java", lang: "java", code: `class Solution {
    public int strStr(String haystack, String needle) {
        if (needle.isEmpty()) return 0;
        
        int needleLen = needle.length();
        int haystackLen = haystack.length();
        
        for (int i = 0; i <= haystackLen - needleLen; i++) {
            if (haystack.substring(i, i + needleLen).equals(needle)) {
                return i;
            }
        }
        
        return -1;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `var strStr = function(haystack, needle) {
    if (needle === "") return 0;
    
    const needleLen = needle.length;
    const haystackLen = haystack.length;
    
    for (let i = 0; i <= haystackLen - needleLen; i++) {
        if (haystack.substring(i, i + needleLen) === needle) {
            return i;
        }
    }
    
    return -1;
};` },
{ name: "C++", lang: "cpp", code: `#include <string>
using namespace std;

class Solution {
public:
    int strStr(string haystack, string needle) {
        if (needle.empty()) return 0;
        
        int needleLen = needle.length();
        int haystackLen = haystack.length();
        
        for (int i = 0; i <= haystackLen - needleLen; i++) {
            if (haystack.substr(i, needleLen) == needle) {
                return i;
            }
        }
        
        return -1;
    }
};` },
{ name: "Python3", lang: "python", code: `def strStr(haystack: str, needle: str) -> int:
    if not needle:
        return 0
    
    needle_len = len(needle)
    haystack_len = len(haystack)
    
    for i in range(haystack_len - needle_len + 1):
        if haystack[i:i + needle_len] == needle:
            return i
    
    return -1` },
{ name: "C", lang: "c", code: `#include <string.h>

int strStr(char* haystack, char* needle) {
    if (needle[0] == '\0') return 0;
    
    int needle_len = strlen(needle);
    int haystack_len = strlen(haystack);
    
    for (int i = 0; i <= haystack_len - needle_len; i++) {
        int j;
        for (j = 0; j < needle_len; j++) {
            if (haystack[i + j] != needle[j]) {
                break;
            }
        }
        if (j == needle_len) {
            return i;
        }
    }
    
    return -1;
}` },
{ name: "C#", lang: "csharp", code: `public class Solution {
    public int StrStr(string haystack, string needle) {
        if (string.IsNullOrEmpty(needle)) return 0;
        
        int needleLen = needle.Length;
        int haystackLen = haystack.Length;
        
        for (int i = 0; i <= haystackLen - needleLen; i++) {
            if (haystack.Substring(i, needleLen).Equals(needle)) {
                return i;
            }
        }
        
        return -1;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function strStr(haystack: string, needle: string): number {
    if (needle === "") return 0;
    
    const needleLen = needle.length;
    const haystackLen = haystack.length;
    
    for (let i = 0; i <= haystackLen - needleLen; i++) {
        if (haystack.substring(i, i + needleLen) === needle) {
            return i;
        }
    }
    
    return -1;
}` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func strStr(_ haystack: String, _ needle: String) -> Int {
        if needle.isEmpty { return 0 }
        
        let needleLen = needle.count
        let haystackLen = haystack.count
        
        guard needleLen <= haystackLen else { return -1 }
        
        let haystackArray = Array(haystack)
        let needleArray = Array(needle)
        
        for i in 0...(haystackLen - needleLen) {
            var found = true
            for j in 0..<needleLen {
                if haystackArray[i + j] != needleArray[j] {
                    found = false
                    break
                }
            }
            if found { return i }
        }
        
        return -1
    }
}` }]} />

**Complexity**

- Time: O(n * m) where n is the length of haystack and m is the length of needle. In the worst case, we check each position in the haystack and compare up to m characters.
- Space: O(1) for most languages that support substring comparison efficiently. However, for languages like Java where substring creates a new string object, it could be O(m).
- Notes: This approach is simple but can be inefficient for large inputs. The worst case occurs when there are many partial matches, forcing repeated comparisons.

---

## KMP Algorithm (Knuth-Morris-Pratt)

**Intuition**

The key idea is to avoid unnecessary comparisons by pre-processing the needle to construct an auxiliary array (failure function or LPS array) that provides information about how the pattern matches against shifts of itself. This allows us to skip ahead when a mismatch occurs, rather than starting the comparison from scratch.

**Steps**

- Pre-process the needle to compute the LPS (Longest Proper Prefix which is also Suffix) array. This array stores the length of the longest proper prefix which is also a suffix for each sub-pattern of the needle.
- Use two pointers, one for the haystack and one for the needle. Iterate through the haystack.
- If characters match, advance both pointers. If they don't match, use the LPS array to determine where to continue matching from in the needle without moving back in the haystack.
- If we reach the end of the needle, we've found a match. Return the starting position of this match in the haystack.
- If we finish processing the haystack without finding a full match, return -1.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def strStr(haystack: str, needle: str) -> int:
    if not needle:
        return 0
    
    def compute_lps(pattern):
        m = len(pattern)
        lps = [0] * m
        length = 0
        i = 1
        
        while i < m:
            if pattern[i] == pattern[length]:
                length += 1
                lps[i] = length
                i += 1
            else:
                if length != 0:
                    length = lps[length - 1]
                else:
                    lps[i] = 0
                    i += 1
        return lps
    
    n, m = len(haystack), len(needle)
    lps = compute_lps(needle)
    
    i = j = 0
    while i < n:
        if needle[j] == haystack[i]:
            i += 1
            j += 1
        
        if j == m:
            return i - j
        elif i < n and needle[j] != haystack[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    
    return -1` },
{ name: "Java", lang: "java", code: `class Solution {
    public int strStr(String haystack, String needle) {
        if (needle.isEmpty()) return 0;
        
        int[] lps = computeLPS(needle);
        
        int i = 0, j = 0;
        int n = haystack.length(), m = needle.length();
        
        while (i < n) {
            if (needle.charAt(j) == haystack.charAt(i)) {
                i++;
                j++;
            }
            
            if (j == m) {
                return i - j;
            } else if (i < n && needle.charAt(j) != haystack.charAt(i)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return -1;
    }
    
    private int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0;
        int i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        return lps;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `var strStr = function(haystack, needle) {
    if (needle === "") return 0;
    
    function computeLPS(pattern) {
        const m = pattern.length;
        const lps = new Array(m).fill(0);
        let len = 0;
        let i = 1;
        
        while (i < m) {
            if (pattern[i] === pattern[len]) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len !== 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        return lps;
    }
    
    const n = haystack.length, m = needle.length;
    const lps = computeLPS(needle);
    
    let i = 0, j = 0;
    while (i < n) {
        if (needle[j] === haystack[i]) {
            i++;
            j++;
        }
        
        if (j === m) {
            return i - j;
        } else if (i < n && needle[j] !== haystack[i]) {
            if (j !== 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
    
    return -1;
};` },
{ name: "C++", lang: "cpp", code: `#include <string>
#include <vector>
using namespace std;

class Solution {
public:
    int strStr(string haystack, string needle) {
        if (needle.empty()) return 0;
        
        vector<int> lps = computeLPS(needle);
        
        int i = 0, j = 0;
        int n = haystack.length(), m = needle.length();
        
        while (i < n) {
            if (needle[j] == haystack[i]) {
                i++;
                j++;
            }
            
            if (j == m) {
                return i - j;
            } else if (i < n && needle[j] != haystack[i]) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return -1;
    }
    
private:
    vector<int> computeLPS(const string& pattern) {
        int m = pattern.length();
        vector<int> lps(m, 0);
        int len = 0;
        int i = 1;
        
        while (i < m) {
            if (pattern[i] == pattern[len]) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        return lps;
    }
};` },
{ name: "Python3", lang: "python", code: `def strStr(haystack: str, needle: str) -> int:
    if not needle:
        return 0
    
    def compute_lps(pattern: str) -> list[int]:
        m = len(pattern)
        lps = [0] * m
        length = 0
        i = 1
        
        while i < m:
            if pattern[i] == pattern[length]:
                length += 1
                lps[i] = length
                i += 1
            else:
                if length != 0:
                    length = lps[length - 1]
                else:
                    lps[i] = 0
                    i += 1
        return lps
    
    n, m = len(haystack), len(needle)
    lps = compute_lps(needle)
    
    i = j = 0
    while i < n:
        if needle[j] == haystack[i]:
            i += 1
            j += 1
        
        if j == m:
            return i - j
        elif i < n and needle[j] != haystack[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    
    return -1` },
{ name: "C", lang: "c", code: `#include <string.h>
#include <stdlib.h>

void computeLPS(char* pattern, int m, int* lps) {
    int len = 0;
    lps[0] = 0;
    int i = 1;
    
    while (i < m) {
        if (pattern[i] == pattern[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
}

int strStr(char* haystack, char* needle) {
    if (needle[0] == '\0') return 0;
    
    int n = strlen(haystack);
    int m = strlen(needle);
    
    int* lps = (int*)malloc(m * sizeof(int));
    computeLPS(needle, m, lps);
    
    int i = 0, j = 0;
    while (i < n) {
        if (needle[j] == haystack[i]) {
            i++;
            j++;
        }
        
        if (j == m) {
            free(lps);
            return i - j;
        } else if (i < n && needle[j] != haystack[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
    
    free(lps);
    return -1;
}` },
{ name: "C#", lang: "csharp", code: `public class Solution {
    public int StrStr(string haystack, string needle) {
        if (string.IsNullOrEmpty(needle)) return 0;
        
        int[] lps = ComputeLPS(needle);
        
        int i = 0, j = 0;
        int n = haystack.Length, m = needle.Length;
        
        while (i < n) {
            if (needle[j] == haystack[i]) {
                i++;
                j++;
            }
            
            if (j == m) {
                return i - j;
            } else if (i < n && needle[j] != haystack[i]) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return -1;
    }
    
    private int[] ComputeLPS(string pattern) {
        int m = pattern.Length;
        int[] lps = new int[m];
        int len = 0;
        int i = 1;
        
        while (i < m) {
            if (pattern[i] == pattern[len]) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        return lps;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function strStr(haystack: string, needle: string): number {
    if (needle === "") return 0;
    
    function computeLPS(pattern: string): number[] {
        const m = pattern.length;
        const lps: number[] = new Array(m).fill(0);
        let len = 0;
        let i = 1;
        
        while (i < m) {
            if (pattern[i] === pattern[len]) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len !== 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        return lps;
    }
    
    const n = haystack.length, m = needle.length;
    const lps = computeLPS(needle);
    
    let i = 0, j = 0;
    while (i < n) {
        if (needle[j] === haystack[i]) {
            i++;
            j++;
        }
        
        if (j === m) {
            return i - j;
        } else if (i < n && needle[j] !== haystack[i]) {
            if (j !== 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
    
    return -1;
}` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func strStr(_ haystack: String, _ needle: String) -> Int {
        if needle.isEmpty { return 0 }
        
        let haystackArray = Array(haystack)
        let needleArray = Array(needle)
        let lps = computeLPS(needleArray)
        
        var i = 0, j = 0
        let n = haystackArray.count, m = needleArray.count
        
        while i < n {
            if needleArray[j] == haystackArray[i] {
                i += 1
                j += 1
            }
            
            if j == m {
                return i - j
            } else if i < n && needleArray[j] != haystackArray[i] {
                if j != 0 {
                    j = lps[j - 1]
                } else {
                    i += 1
                }
            }
        }
        
        return -1
    }
    
    private func computeLPS(_ pattern: [Character]) -> [Int] {
        let m = pattern.count
        var lps = Array(repeating: 0, count: m)
        var len = 0
        var i = 1
        
        while i < m {
            if pattern[i] == pattern[len] {
                len += 1
                lps[i] = len
                i += 1
            } else {
                if len != 0 {
                    len = lps[len - 1]
                } else {
                    lps[i] = 0
                    i += 1
                }
            }
        }
        return lps
    }
}` }]} />

**Complexity**

- Time: O(n + m) where n is the length of haystack and m is the length of needle. Both the preprocessing of the needle (LPS array computation) and the main matching process take linear time.
- Space: O(m) for storing the LPS array of size m.
- Notes: This is the optimal algorithm for this problem. It avoids backtracking in the haystack by using information from previous matches. It's particularly efficient when the needle has repetitive patterns.

---

## Rabin-Karp Algorithm

**Intuition**

Instead of comparing characters directly, we can use hashing to compare substrings. Compute a hash of the needle and then compute rolling hashes of substrings of the haystack with the same length as the needle. When a hash matches, we do a character-by-character verification to avoid false positives due to hash collisions.

**Steps**

- Choose a suitable base and a large prime number for the hash function. Calculate the hash of the needle.
- Calculate the hash of the first window (substring of haystack with length equal to needle) in the haystack.
- Use a rolling hash technique to compute hashes of subsequent windows in constant time.
- When a hash value matches that of the needle, perform a character-by-character comparison to confirm the match (to handle hash collisions).
- If a confirmed match is found, return the starting index of the window. If no match is found after checking all windows, return -1.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def strStr(haystack: str, needle: str) -> int:
    if not needle:
        return 0
    
    base = 256
    prime = 101
    
    n, m = len(haystack), len(needle)
    if m > n:
        return -1
    
    # Calculate hash of needle and first window of haystack
    needle_hash = 0
    window_hash = 0
    h = 1
    
    # Calculate h = pow(base, m-1) % prime
    for i in range(m - 1):
        h = (h * base) % prime
    
    for i in range(m):
        needle_hash = (base * needle_hash + ord(needle[i])) % prime
        window_hash = (base * window_hash + ord(haystack[i])) % prime
    
    # Slide the window over haystack
    for i in range(n - m + 1):
        if needle_hash == window_hash:
            # Check characters one by one
            if haystack[i:i + m] == needle:
                return i
        
        # Calculate hash for next window
        if i < n - m:
            window_hash = (base * (window_hash - ord(haystack[i]) * h) + ord(haystack[i + m])) % prime
            if window_hash < 0:
                window_hash += prime
    
    return -1` },
{ name: "Java", lang: "java", code: `class Solution {
    public int strStr(String haystack, String needle) {
        if (needle.isEmpty()) return 0;
        
        int base = 256;
        int prime = 101;
        
        int n = haystack.length(), m = needle.length();
        if (m > n) return -1;
        
        long needleHash = 0;
        long windowHash = 0;
        long h = 1;
        
        // Calculate h = pow(base, m-1) % prime
        for (int i = 0; i < m - 1; i++) {
            h = (h * base) % prime;
        }
        
        // Calculate hash of needle and first window
        for (int i = 0; i < m; i++) {
            needleHash = (base * needleHash + needle.charAt(i)) % prime;
            windowHash = (base * windowHash + haystack.charAt(i)) % prime;
        }
        
        // Slide the window over haystack
        for (int i = 0; i <= n - m; i++) {
            if (needleHash == windowHash) {
                // Check characters one by one
                if (haystack.substring(i, i + m).equals(needle)) {
                    return i;
                }
            }
            
            // Calculate hash for next window
            if (i < n - m) {
                windowHash = (base * (windowHash - haystack.charAt(i) * h) + haystack.charAt(i + m)) % prime;
                if (windowHash < 0) {
                    windowHash += prime;
                }
            }
        }
        
        return -1;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `var strStr = function(haystack, needle) {
    if (needle === "") return 0;
    
    const base = 256;
    const prime = 101;
    
    const n = haystack.length, m = needle.length;
    if (m > n) return -1;
    
    let needleHash = 0;
    let windowHash = 0;
    let h = 1;
    
    // Calculate h = pow(base, m-1) % prime
    for (let i = 0; i < m - 1; i++) {
        h = (h * base) % prime;
    }
    
    // Calculate hash of needle and first window
    for (let i = 0; i < m; i++) {
        needleHash = (base * needleHash + needle.charCodeAt(i)) % prime;
        windowHash = (base * windowHash + haystack.charCodeAt(i)) % prime;
    }
    
    // Slide the window over haystack
    for (let i = 0; i <= n - m; i++) {
        if (needleHash === windowHash) {
            // Check characters one by one
            if (haystack.substring(i, i + m) === needle) {
                return i;
            }
        }
        
        // Calculate hash for next window
        if (i < n - m) {
            windowHash = (base * (windowHash - haystack.charCodeAt(i) * h) + haystack.charCodeAt(i + m)) % prime;
            if (windowHash < 0) {
                windowHash += prime;
            }
        }
    }
    
    return -1;
};` },
{ name: "C++", lang: "cpp", code: `#include <string>
using namespace std;

class Solution {
public:
    int strStr(string haystack, string needle) {
        if (needle.empty()) return 0;
        
        int base = 256;
        int prime = 101;
        
        int n = haystack.length(), m = needle.length();
        if (m > n) return -1;
        
        long long needleHash = 0;
        long long windowHash = 0;
        long long h = 1;
        
        // Calculate h = pow(base, m-1) % prime
        for (int i = 0; i < m - 1; i++) {
            h = (h * base) % prime;
        }
        
        // Calculate hash of needle and first window
        for (int i = 0; i < m; i++) {
            needleHash = (base * needleHash + needle[i]) % prime;
            windowHash = (base * windowHash + haystack[i]) % prime;
        }
        
        // Slide the window over haystack
        for (int i = 0; i <= n - m; i++) {
            if (needleHash == windowHash) {
                // Check characters one by one
                if (haystack.substr(i, m) == needle) {
                    return i;
                }
            }
            
            // Calculate hash for next window
            if (i < n - m) {
                windowHash = (base * (windowHash - haystack[i] * h) + haystack[i + m]) % prime;
                if (windowHash < 0) {
                    windowHash += prime;
                }
            }
        }
        
        return -1;
    }
};` },
{ name: "Python3", lang: "python", code: `def strStr(haystack: str, needle: str) -> int:
    if not needle:
        return 0
    
    base = 256
    prime = 101
    
    n, m = len(haystack), len(needle)
    if m > n:
        return -1
    
    needle_hash = 0
    window_hash = 0
    h = 1
    
    # Calculate h = pow(base, m-1) % prime
    for i in range(m - 1):
        h = (h * base) % prime
    
    # Calculate hash of needle and first window
    for i in range(m):
        needle_hash = (base * needle_hash + ord(needle[i])) % prime
        window_hash = (base * window_hash + ord(haystack[i])) % prime
    
    # Slide the window over haystack
    for i in range(n - m + 1):
        if needle_hash == window_hash:
            # Check characters one by one
            if haystack[i:i + m] == needle:
                return i
        
        # Calculate hash for next window
        if i < n - m:
            window_hash = (base * (window_hash - ord(haystack[i]) * h) + ord(haystack[i + m])) % prime
            if window_hash < 0:
                window_hash += prime
    
    return -1` },
{ name: "C", lang: "c", code: `#include <string.h>

int strStr(char* haystack, char* needle) {
    if (needle[0] == '\0') return 0;
    
    int base = 256;
    int prime = 101;
    
    int n = strlen(haystack), m = strlen(needle);
    if (m > n) return -1;
    
    long long needleHash = 0;
    long long windowHash = 0;
    long long h = 1;
    
    // Calculate h = pow(base, m-1) % prime
    for (int i = 0; i < m - 1; i++) {
        h = (h * base) % prime;
    }
    
    // Calculate hash of needle and first window
    for (int i = 0; i < m; i++) {
        needleHash = (base * needleHash + needle[i]) % prime;
        windowHash = (base * windowHash + haystack[i]) % prime;
    }
    
    // Slide the window over haystack
    for (int i = 0; i <= n - m; i++) {
        if (needleHash == windowHash) {
            // Check characters one by one
            int j;
            for (j = 0; j < m; j++) {
                if (haystack[i + j] != needle[j]) {
                    break;
                }
            }
            if (j == m) {
                return i;
            }
        }
        
        // Calculate hash for next window
        if (i < n - m) {
            windowHash = (base * (windowHash - haystack[i] * h) + haystack[i + m]) % prime;
            if (windowHash < 0) {
                windowHash += prime;
            }
        }
    }
    
    return -1;
}` },
{ name: "C#", lang: "csharp", code: `public class Solution {
    public int StrStr(string haystack, string needle) {
        if (string.IsNullOrEmpty(needle)) return 0;
        
        int base = 256;
        int prime = 101;
        
        int n = haystack.Length, m = needle.Length;
        if (m > n) return -1;
        
        long needleHash = 0;
        long windowHash = 0;
        long h = 1;
        
        // Calculate h = pow(base, m-1) % prime
        for (int i = 0; i < m - 1; i++) {
            h = (h * base) % prime;
        }
        
        // Calculate hash of needle and first window
        for (int i = 0; i < m; i++) {
            needleHash = (base * needleHash + needle[i]) % prime;
            windowHash = (base * windowHash + haystack[i]) % prime;
        }
        
        // Slide the window over haystack
        for (int i = 0; i <= n - m; i++) {
            if (needleHash == windowHash) {
                // Check characters one by one
                if (haystack.Substring(i, m).Equals(needle)) {
                    return i;
                }
            }
            
            // Calculate hash for next window
            if (i < n - m) {
                windowHash = (base * (windowHash - haystack[i] * h) + haystack[i + m]) % prime;
                if (windowHash < 0) {
                    windowHash += prime;
                }
            }
        }
        
        return -1;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function strStr(haystack: string, needle: string): number {
    if (needle === "") return 0;
    
    const base = 256;
    const prime = 101;
    
    const n = haystack.length, m = needle.length;
    if (m > n) return -1;
    
    let needleHash = 0;
    let windowHash = 0;
    let h = 1;
    
    // Calculate h = pow(base, m-1) % prime
    for (let i = 0; i < m - 1; i++) {
        h = (h * base) % prime;
    }
    
    // Calculate hash of needle and first window
    for (let i = 0; i < m; i++) {
        needleHash = (base * needleHash + needle.charCodeAt(i)) % prime;
        windowHash = (base * windowHash + haystack.charCodeAt(i)) % prime;
    }
    
    // Slide the window over haystack
    for (let i = 0; i <= n - m; i++) {
        if (needleHash === windowHash) {
            // Check characters one by one
            if (haystack.substring(i, i + m) === needle) {
                return i;
            }
        }
        
        // Calculate hash for next window
        if (i < n - m) {
            windowHash = (base * (windowHash - haystack.charCodeAt(i) * h) + haystack.charCodeAt(i + m)) % prime;
            if (windowHash < 0) {
                windowHash += prime;
            }
        }
    }
    
    return -1;
}` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func strStr(_ haystack: String, _ needle: String) -> Int {
        if needle.isEmpty { return 0 }
        
        let base = 256
        let prime = 101
        
        let haystackArray = Array(haystack)
        let needleArray = Array(needle)
        let n = haystackArray.count, m = needleArray.count
        
        if m > n { return -1 }
        
        var needleHash = 0
        var windowHash = 0
        var h = 1
        
        // Calculate h = pow(base, m-1) % prime
        for _ in 0..<m-1 {
            h = (h * base) % prime
        }
        
        // Calculate hash of needle and first window
        for i in 0..<m {
            needleHash = (base * needleHash + Int(needleArray[i].asciiValue!)) % prime
            windowHash = (base * windowHash + Int(haystackArray[i].asciiValue!)) % prime
        }
        
        // Slide the window over haystack
        for i in 0...n-m {
            if needleHash == windowHash {
                // Check characters one by one
                var found = true
                for j in 0..<m {
                    if haystackArray[i + j] != needleArray[j] {
                        found = false
                        break
                    }
                }
                if found { return i }
            }
            
            // Calculate hash for next window
            if i < n - m {
                windowHash = (base * (windowHash - Int(haystackArray[i].asciiValue!) * h) + Int(haystackArray[i + m].asciiValue!)) % prime
                if windowHash < 0 {
                    windowHash += prime
                }
            }
        }
        
        return -1
    }
}` }]} />

**Complexity**

- Time: Average and best case: O(n + m) where n is the length of haystack and m is the length of needle. Worst case: O(n * m) when there are many spurious hits requiring character-by-character verification.
- Space: O(1) as we only use a constant amount of extra space.
- Notes: The Rabin-Karp algorithm is particularly useful when searching for multiple patterns or when the alphabet size is large. The performance depends on the choice of base and prime numbers for the hash function, and the likelihood of hash collisions.


<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"TechArticle","headline":"LeetCode Find the Index of the First Occurrence in a String Solutions","datePublished":"2025-09-18T04:02:48.744Z","description":"Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.","keywords":"LeetCode, Find the Index of the First Occurrence in a String, Easy, Two Pointers, String, String Matching, Hash Map, Brute Force, Array"}).replace(/</g,'\\u003c')}
</script>

<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"Brute Force / Naive String Matching complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n * m) where n is the length of haystack and m is the length of needle. In the worst case, we check each position in the haystack and compare up to m characters.; Space: O(1) for most languages that support substring comparison efficiently. However, for languages like Java where substring creates a new string object, it could be O(m).. This approach is simple but can be inefficient for large inputs. The worst case occurs when there are many partial matches, forcing repeated comparisons."}},{"@type":"Question","name":"KMP Algorithm (Knuth-Morris-Pratt) complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n + m) where n is the length of haystack and m is the length of needle. Both the preprocessing of the needle (LPS array computation) and the main matching process take linear time.; Space: O(m) for storing the LPS array of size m.. This is the optimal algorithm for this problem. It avoids backtracking in the haystack by using information from previous matches. It's particularly efficient when the needle has repetitive patterns."}},{"@type":"Question","name":"Rabin-Karp Algorithm complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: Average and best case: O(n + m) where n is the length of haystack and m is the length of needle. Worst case: O(n * m) when there are many spurious hits requiring character-by-character verification.; Space: O(1) as we only use a constant amount of extra space.. The Rabin-Karp algorithm is particularly useful when searching for multiple patterns or when the alphabet size is large. The performance depends on the choice of base and prime numbers for the hash function, and the likelihood of hash collisions."}}]}).replace(/</g,'\\u003c')}
</script>
