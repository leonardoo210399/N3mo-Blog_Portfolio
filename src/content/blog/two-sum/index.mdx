---
title: "3Sum"
summary: "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets."
date: "Sep 06, 2025"
tags:
  - Add Two Numbers
  - LeetCode
  - Medium
  - Linked List
  - Math
  - Recursion
  - Algorithms
  - Data Structures
  - Brute Force Approach
  - Optimized Two Pointers Approach
  - Hash Map Approach
draft: false
difficulty: Medium
---

import CodeTabs from "@components/CodeTabs"

> **Difficulty:** Medium | **Acceptance:** 46.79% | **Paid:** No

> **Topics:** Linked List, Math, Recursion

- Examples
- Constraints
- [Brute Force Approach](#brute-force-approach)
- [Optimized Two Pointers Approach](#optimized-two-pointers-approach)
- [Hash Map Approach](#hash-map-approach)

## Examples

**Input**

```text
nums = [-1,0,1,2,-1,-4]
```

**Output**

```text
[[-1,-1,2],[-1,0,1]]
```

**Input**

```text
nums = [0,1,1]
```

**Output**

```text
[]
```

**Input**

```text
nums = [0,0,0]
```

**Output**

```text
[[0,0,0]]
```

## Constraints

```text
- 3 <= nums.length <= 3000 
- -105 <= nums[i] <= 105 
```
---

## Brute Force Approach

**Intuition**

Check all possible triplets and verify if their sum is zero while ensuring indices are different and avoiding duplicates.

**Steps**

- Use three nested loops to iterate through all possible combinations of three elements.
- For each triplet, check if their sum equals zero.
- Use a set or similar structure to avoid adding duplicate triplets to the result.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def threeSum(nums):
    result = set()
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                if nums[i] + nums[j] + nums[k] == 0:
                    triplet = tuple(sorted([nums[i], nums[j], nums[k]]))
                    result.add(triplet)
    return [list(triplet) for triplet in result]` },
{ name: "Java", lang: "java", code: `import java.util.*;
public class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Set<List<Integer>> result = new HashSet<>();
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                for (int k = j + 1; k < n; k++) {
                    if (nums[i] + nums[j] + nums[k] == 0) {
                        List<Integer> triplet = Arrays.asList(nums[i], nums[j], nums[k]);
                        Collections.sort(triplet);
                        result.add(triplet);
                    }
                }
            }
        }
        return new ArrayList<>(result);
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `function threeSum(nums) {
    const result = new Set();
    const n = nums.length;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            for (let k = j + 1; k < n; k++) {
                if (nums[i] + nums[j] + nums[k] === 0) {
                    const triplet = [nums[i], nums[j], nums[k]].sort((a, b) => a - b);
                    result.add(JSON.stringify(triplet));
                }
            }
        }
    }
    return Array.from(result).map(JSON.parse);
}` },
{ name: "C++", lang: "cpp", code: `#include <vector>
#include <set>
#include <algorithm>
using namespace std;
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        set<vector<int>> result;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                for (int k = j + 1; k < n; k++) {
                    if (nums[i] + nums[j] + nums[k] == 0) {
                        vector<int> triplet = {nums[i], nums[j], nums[k]};
                        sort(triplet.begin(), triplet.end());
                        result.insert(triplet);
                    }
                }
            }
        }
        return vector<vector<int>>(result.begin(), result.end());
    }
};` },
{ name: "Python3", lang: "python", code: `def threeSum(nums):
    result = set()
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                if nums[i] + nums[j] + nums[k] == 0:
                    triplet = tuple(sorted([nums[i], nums[j], nums[k]]))
                    result.add(triplet)
    return [list(triplet) for triplet in result]` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <stdlib.h>
int compare(const void* a, const void* b) { return (*(int*)a - *(int*)b); }
int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {
    *returnSize = 0;
    int** result = (int**)malloc(1000 * sizeof(int*));
    *returnColumnSizes = (int*)malloc(1000 * sizeof(int));
    for (int i = 0; i < numsSize; i++) {
        for (int j = i + 1; j < numsSize; j++) {
            for (int k = j + 1; k < numsSize; k++) {
                if (nums[i] + nums[j] + nums[k] == 0) {
                    int triplet[3] = {nums[i], nums[j], nums[k]};
                    qsort(triplet, 3, sizeof(int), compare);
                    int found = 0;
                    for (int idx = 0; idx < *returnSize; idx++) {
                        if (result[idx][0] == triplet[0] && result[idx][1] == triplet[1] && result[idx][2] == triplet[2]) {
                            found = 1; break;
                        }
                    }
                    if (!found) {
                        result[*returnSize] = (int*)malloc(3 * sizeof(int));
                        result[*returnSize][0] = triplet[0];
                        result[*returnSize][1] = triplet[1];
                        result[*returnSize][2] = triplet[2];
                        (*returnColumnSizes)[*returnSize] = 3;
                        (*returnSize)++;
                    }
                }
            }
        }
    }
    return result;
}` },
{ name: "C#", lang: "csharp", code: `using System;
using System.Collections.Generic;
public class Solution {
    public IList<IList<int>> ThreeSum(int[] nums) {
        var result = new HashSet<string>();
        var finalResult = new List<IList<int>>();
        int n = nums.Length;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                for (int k = j + 1; k < n; k++) {
                    if (nums[i] + nums[j] + nums[k] == 0) {
                        int[] triplet = { nums[i], nums[j], nums[k] };
                        Array.Sort(triplet);
                        string key = string.Join(",", triplet);
                        if (!result.Contains(key)) {
                            result.Add(key);
                            finalResult.Add(new List<int>(triplet));
                        }
                    }
                }
            }
        }
        return finalResult;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function threeSum(nums: number[]): number[][] {
    const result = new Set<string>();
    const n = nums.length;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            for (let k = j + 1; k < n; k++) {
                if (nums[i] + nums[j] + nums[k] === 0) {
                    const triplet = [nums[i], nums[j], nums[k]].sort((a, b) => a - b);
                    result.add(JSON.stringify(triplet));
                }
            }
        }
    }
    return Array.from(result).map(JSON.parse);
}` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func threeSum(_ nums: [Int]) -> [[Int]] {
        var result: Set<[Int]> = []
        let n = nums.count
        for i in 0..<n {
            for j in (i+1)..<n {
                for k in (j+1)..<n {
                    if nums[i] + nums[j] + nums[k] == 0 {
                        let triplet = [nums[i], nums[j], nums[k]].sorted()
                        result.insert(triplet)
                    }
                }
            }
        }
        return Array(result)
    }
}` }]} />

**Complexity**

- Time: O(n^3)
- Space: O(1) excluding the space for the output list
- Notes: This approach is inefficient for large inputs due to the cubic time complexity.

---

## Optimized Two Pointers Approach

**Intuition**

Sort the array and use a two-pointer technique to find pairs that sum with a fixed element to zero, thus reducing time complexity.

**Steps**

- Sort the array to make two-pointer traversal possible.
- Iterate through each element as the first element of a potential triplet.
- For each element, use two pointers (left and right) to efficiently find pairs whose sum with the current element equals zero.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def threeSum(nums):
    nums.sort()
    result = []
    n = len(nums)
    for i in range(n - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, n - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total < 0:
                left += 1
            elif total > 0:
                right -= 1
            else:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
    return result` },
{ name: "Java", lang: "java", code: `import java.util.*;
public class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        int n = nums.length;
        for (int i = 0; i < n - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1, right = n - 1;
            while (left < right) {
                int total = nums[i] + nums[left] + nums[right];
                if (total < 0) {
                    left++;
                } else if (total > 0) {
                    right--;
                } else {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                }
            }
        }
        return result;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `function threeSum(nums) {
    nums.sort((a, b) => a - b);
    const result = [];
    const n = nums.length;
    for (let i = 0; i < n - 2; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue;
        let left = i + 1, right = n - 1;
        while (left < right) {
            const total = nums[i] + nums[left] + nums[right];
            if (total < 0) {
                left++;
            } else if (total > 0) {
                right--;
            } else {
                result.push([nums[i], nums[left], nums[right]]);
                while (left < right && nums[left] === nums[left + 1]) left++;
                while (left < right && nums[right] === nums[right - 1]) right--;
                left++;
                right--;
            }
        }
    }
    return result;
}` },
{ name: "C++", lang: "cpp", code: `#include <vector>
#include <algorithm>
using namespace std;
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result;
        int n = nums.size();
        for (int i = 0; i < n - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1, right = n - 1;
            while (left < right) {
                int total = nums[i] + nums[left] + nums[right];
                if (total < 0) {
                    left++;
                } else if (total > 0) {
                    right--;
                } else {
                    result.push_back({nums[i], nums[left], nums[right]});
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                }
            }
        }
        return result;
    }
};` },
{ name: "Python3", lang: "python", code: `def threeSum(nums):
    nums.sort()
    result = []
    n = len(nums)
    for i in range(n - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, n - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total < 0:
                left += 1
            elif total > 0:
                right -= 1
            else:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
    return result` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <stdlib.h>
int compare(const void* a, const void* b) { return (*(int*)a - *(int*)b); }
int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {
    qsort(nums, numsSize, sizeof(int), compare);
    int** result = (int**)malloc(numsSize * numsSize * sizeof(int*));
    *returnColumnSizes = (int*)malloc(numsSize * numsSize * sizeof(int));
    *returnSize = 0;
    for (int i = 0; i < numsSize - 2; i++) {
        if (i > 0 && nums[i] == nums[i - 1]) continue;
        int left = i + 1, right = numsSize - 1;
        while (left < right) {
            int total = nums[i] + nums[left] + nums[right];
            if (total < 0) {
                left++;
            } else if (total > 0) {
                right--;
            } else {
                result[*returnSize] = (int*)malloc(3 * sizeof(int));
                result[*returnSize][0] = nums[i];
                result[*returnSize][1] = nums[left];
                result[*returnSize][2] = nums[right];
                (*returnColumnSizes)[*returnSize] = 3;
                (*returnSize)++;
                while (left < right && nums[left] == nums[left + 1]) left++;
                while (left < right && nums[right] == nums[right - 1]) right--;
                left++;
                right--;
            }
        }
    }
    return result;
}` },
{ name: "C#", lang: "csharp", code: `using System;
using System.Collections.Generic;
public class Solution {
    public IList<IList<int>> ThreeSum(int[] nums) {
        Array.Sort(nums);
        var result = new List<IList<int>>();
        int n = nums.Length;
        for (int i = 0; i < n - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1, right = n - 1;
            while (left < right) {
                int total = nums[i] + nums[left] + nums[right];
                if (total < 0) {
                    left++;
                } else if (total > 0) {
                    right--;
                } else {
                    result.Add(new List<int> { nums[i], nums[left], nums[right] });
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                }
            }
        }
        return result;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function threeSum(nums: number[]): number[][] {
    nums.sort((a, b) => a - b);
    const result: number[][] = [];
    const n = nums.length;
    for (let i = 0; i < n - 2; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue;
        let left = i + 1, right = n - 1;
        while (left < right) {
            const total = nums[i] + nums[left] + nums[right];
            if (total < 0) {
                left++;
            } else if (total > 0) {
                right--;
            } else {
                result.push([nums[i], nums[left], nums[right]]);
                while (left < right && nums[left] === nums[left + 1]) left++;
                while (left < right && nums[right] === nums[right - 1]) right--;
                left++;
                right--;
            }
        }
    }
    return result;
}` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func threeSum(_ nums: [Int]) -> [[Int]] {
        let sortedNums = nums.sorted()
        var result: [[Int]] = []
        let n = sortedNums.count
        for i in 0..<(n - 2) {
            if i > 0 && sortedNums[i] == sortedNums[i - 1] { continue }
            var left = i + 1
            var right = n - 1
            while left < right {
                let total = sortedNums[i] + sortedNums[left] + sortedNums[right]
                if total < 0 {
                    left += 1
                } else if total > 0 {
                    right -= 1
                } else {
                    result.append([sortedNums[i], sortedNums[left], sortedNums[right]])
                    while left < right && sortedNums[left] == sortedNums[left + 1] { left += 1 }
                    while left < right && sortedNums[right] == sortedNums[right - 1] { right -= 1 }
                    left += 1
                    right -= 1
                }
            }
        }
        return result
    }
}` }]} />

**Complexity**

- Time: O(n^2)
- Space: O(1) excluding the space for the output list
- Notes: This approach is significantly more efficient than the brute force method and is suitable for large inputs.

---

## Hash Map Approach

**Intuition**

For each element, use a hash map to find if there exists two other elements that sum with it to zero.

**Steps**

- Sort the array to handle duplicates and allow easier iteration through elements.
- For each element, treat it as the first element of a triplet.
- Use a hash map to find the remaining two elements that sum with the current element to zero, avoiding duplicates.
- Ensure no duplicate triplets are added to the result.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def threeSum(nums):
    nums.sort()
    result = []
    n = len(nums)
    for i in range(n - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        seen = {}
        for j in range(i + 1, n):
            complement = -nums[i] - nums[j]
            if complement in seen:
                result.append([nums[i], complement, nums[j]])
                while j + 1 < n and nums[j] == nums[j + 1]:
                    j += 1
            seen[nums[j]] = j
    return result` },
{ name: "Java", lang: "java", code: `import java.util.*;
public class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        int n = nums.length;
        for (int i = 0; i < n - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            Map<Integer, Integer> seen = new HashMap<>();
            for (int j = i + 1; j < n; j++) {
                int complement = -nums[i] - nums[j];
                if (seen.containsKey(complement)) {
                    result.add(Arrays.asList(nums[i], complement, nums[j]));
                    while (j + 1 < n && nums[j] == nums[j + 1]) j++;
                }
                seen.put(nums[j], j);
            }
        }
        return result;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `function threeSum(nums) {
    nums.sort((a, b) => a - b);
    const result = [];
    const n = nums.length;
    for (let i = 0; i < n - 2; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue;
        const seen = new Map();
        for (let j = i + 1; j < n; j++) {
            const complement = -nums[i] - nums[j];
            if (seen.has(complement)) {
                result.push([nums[i], complement, nums[j]]);
                while (j + 1 < n && nums[j] === nums[j + 1]) j++;
            }
            seen.set(nums[j], j);
        }
    }
    return result;
}` },
{ name: "C++", lang: "cpp", code: `#include <vector>
#include <unordered_map>
#include <algorithm>
using namespace std;
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result;
        int n = nums.size();
        for (int i = 0; i < n - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            unordered_map<int, int> seen;
            for (int j = i + 1; j < n; j++) {
                int complement = -nums[i] - nums[j];
                if (seen.find(complement) != seen.end()) {
                    result.push_back({nums[i], complement, nums[j]});
                    while (j + 1 < n && nums[j] == nums[j + 1]) j++;
                }
                seen[nums[j]] = j;
            }
        }
        return result;
    }
};` },
{ name: "Python3", lang: "python", code: `def threeSum(nums):
    nums.sort()
    result = []
    n = len(nums)
    for i in range(n - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        seen = {}
        for j in range(i + 1, n):
            complement = -nums[i] - nums[j]
            if complement in seen:
                result.append([nums[i], complement, nums[j]])
                while j + 1 < n and nums[j] == nums[j + 1]:
                    j += 1
            seen[nums[j]] = j
    return result` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int compare(const void* a, const void* b) { return (*(int*)a - *(int*)b); }
int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {
    qsort(nums, numsSize, sizeof(int), compare);
    int** result = (int**)malloc(numsSize * numsSize * sizeof(int*));
    *returnColumnSizes = (int*)malloc(numsSize * numsSize * sizeof(int));
    *returnSize = 0;
    for (int i = 0; i < numsSize - 2; i++) {
        if (i > 0 && nums[i] == nums[i - 1]) continue;
        int seen[200001] = {0};
        for (int j = i + 1; j < numsSize; j++) {
            int complement = -nums[i] - nums[j];
            if (complement + 100000 >= 0 && complement + 100000 <= 200000 && seen[complement + 100000]) {
                result[*returnSize] = (int*)malloc(3 * sizeof(int));
                result[*returnSize][0] = nums[i];
                result[*returnSize][1] = complement;
                result[*returnSize][2] = nums[j];
                (*returnColumnSizes)[*returnSize] = 3;
                (*returnSize)++;
                while (j + 1 < numsSize && nums[j] == nums[j + 1]) j++;
            }
            seen[nums[j] + 100000] = 1;
        }
    }
    return result;
}` },
{ name: "C#", lang: "csharp", code: `using System;
using System.Collections.Generic;
public class Solution {
    public IList<IList<int>> ThreeSum(int[] nums) {
        Array.Sort(nums);
        var result = new List<IList<int>>();
        int n = nums.Length;
        for (int i = 0; i < n - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            var seen = new Dictionary<int, int>();
            for (int j = i + 1; j < n; j++) {
                int complement = -nums[i] - nums[j];
                if (seen.ContainsKey(complement)) {
                    result.Add(new List<int> { nums[i], complement, nums[j] });
                    while (j + 1 < n && nums[j] == nums[j + 1]) j++;
                }
                seen[nums[j]] = j;
            }
        }
        return result;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function threeSum(nums: number[]): number[][] {
    nums.sort((a, b) => a - b);
    const result: number[][] = [];
    const n = nums.length;
    for (let i = 0; i < n - 2; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) continue;
        const seen = new Map<number, number>();
        for (let j = i + 1; j < n; j++) {
            const complement = -nums[i] - nums[j];
            if (seen.has(complement)) {
                result.push([nums[i], complement, nums[j]]);
                while (j + 1 < n && nums[j] === nums[j + 1]) j++;
            }
            seen.set(nums[j], j);
        }
    }
    return result;
}` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func threeSum(_ nums: [Int]) -> [[Int]] {
        let sortedNums = nums.sorted()
        var result: [[Int]] = []
        let n = sortedNums.count
        for i in 0..<(n - 2) {
            if i > 0 && sortedNums[i] == sortedNums[i - 1] { continue }
            var seen: [Int: Int] = [:]
            for j in (i+1)..<n {
                let complement = -sortedNums[i] - sortedNums[j]
                if let _ = seen[complement] {
                    result.append([sortedNums[i], complement, sortedNums[j]])
                    var tempJ = j
                    while tempJ + 1 < n && sortedNums[tempJ] == sortedNums[tempJ + 1] { tempJ += 1 }
                    j = tempJ
                }
                seen[sortedNums[j]] = j
            }
        }
        return result
    }
}` }]} />

**Complexity**

- Time: O(n^2)
- Space: O(n) for the hash map
- Notes: This approach also achieves quadratic time complexity, but uses extra space for the hash map which can be significant for large inputs.

