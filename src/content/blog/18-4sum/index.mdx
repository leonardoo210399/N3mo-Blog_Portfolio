---
title: "4Sum"
summary: "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that: 0 <= a, b, c, d < n; a, b, c, and d are distinct; and nums[a] + nums[b] + nums[c] + nums[d] == target. You may return the answer in any order."
date: "Sep 09, 2025"
tags:
  - Array
  - Two Pointers
  - Sorting
draft: false
difficulty: "Medium"
---

import CodeTabs from "@components/CodeTabs"

> **Difficulty:** Medium | **Acceptance:** 38.76% | **Paid:** No

> **Topics:** Array, Two Pointers, Sorting

- Examples
- Constraints
- [Brute Force with Sorting and Nested Loops](#brute-force-with-sorting-and-nested-loops)
- [Optimized Two-Pointer Technique](#optimized-two-pointer-technique)
- [Generalized K-Sum with Recursion](#generalized-k-sum-with-recursion)

## Examples

**Input**

```text
nums = [1,0,-1,0,-2,2], target = 0
```

**Output**

```text
[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**Input**

```text
nums = [2,2,2,2,2], target = 8
```

**Output**

```text
[[2,2,2,2]]
```

## Constraints

```text
- 1 <= nums.length <= 200
- -10^9 <= nums[i] <= 10^9
- -10^9 <= target <= 10^9
```
---

## Brute Force with Sorting and Nested Loops

**Intuition**

We can generate all possible combinations of four elements from the array using four nested loops. To avoid duplicate quadruplets, we'll sort the array first and store the results in a set data structure, which automatically handles duplicates.

**Steps**

- Sort the input array to bring similar elements together and make it easier to skip duplicates.
- Use four nested loops to iterate through all possible combinations of four indices (i, j, k, l) where 0 <= i < j < k < l < n.
- For each combination, calculate the sum of the four elements.
- If the sum equals the target, add the sorted quadruplet to a set to ensure uniqueness.
- Convert the set to a list and return it as the final result.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `from typing import List

def fourSum_bruteforce(nums: List[int], target: int) -> List[List[int]]:
    nums.sort()
    n = len(nums)
    result = set()
    
    for i in range(n):
        for j in range(i+1, n):
            for k in range(j+1, n):
                for l in range(k+1, n):
                    if nums[i] + nums[j] + nums[k] + nums[l] == target:
                        result.add((nums[i], nums[j], nums[k], nums[l]))
    
    return [list(quadruplet) for quadruplet in result]` },
{ name: "Java", lang: "java", code: `import java.util.*;

class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        int n = nums.length;
        Set<List<Integer>> resultSet = new HashSet<>();
        
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                for (int k = j + 1; k < n; k++) {
                    for (int l = k + 1; l < n; l++) {
                        if ((long)nums[i] + nums[j] + nums[k] + nums[l] == target) {
                            List<Integer> quadruplet = Arrays.asList(nums[i], nums[j], nums[k], nums[l]);
                            resultSet.add(quadruplet);
                        }
                    }
                }
            }
        }
        
        return new ArrayList<>(resultSet);
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
    nums.sort((a, b) => a - b);
    const n = nums.length;
    const resultSet = new Set();
    
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            for (let k = j + 1; k < n; k++) {
                for (let l = k + 1; l < n; l++) {
                    if (nums[i] + nums[j] + nums[k] + nums[l] === target) {
                        const quadruplet = [nums[i], nums[j], nums[k], nums[l]];
                        resultSet.add(JSON.stringify(quadruplet));
                    }
                }
            }
        }
    }
    
    return Array.from(resultSet).map(JSON.parse);
};` },
{ name: "C++", lang: "cpp", code: `#include <vector>
#include <set>
#include <algorithm>

class Solution {
public:
    std::vector<std::vector<int>> fourSum(std::vector<int>& nums, int target) {
        std::sort(nums.begin(), nums.end());
        int n = nums.size();
        std::set<std::vector<int>> resultSet;
        
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                for (int k = j + 1; k < n; k++) {
                    for (int l = k + 1; l < n; l++) {
                        long long sum = (long long)nums[i] + nums[j] + nums[k] + nums[l];
                        if (sum == target) {
                            resultSet.insert({nums[i], nums[j], nums[k], nums[l]});
                        }
                    }
                }
            }
        }
        
        return std::vector<std::vector<int>>(resultSet.begin(), resultSet.end());
    }
};` },
{ name: "Python3", lang: "python", code: `from typing import List

class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        n = len(nums)
        result = set()
        
        for i in range(n):
            for j in range(i+1, n):
                for k in range(j+1, n):
                    for l in range(k+1, n):
                        if nums[i] + nums[j] + nums[k] + nums[l] == target:
                            result.add((nums[i], nums[j], nums[k], nums[l]))
        
        return [list(quadruplet) for quadruplet in result]` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <stdlib.h>

// Comparison function for qsort
int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes){
    // This is a simplified version and doesn't fully implement the logic due to C's limitations
    // In practice, this would require complex memory management
    qsort(nums, numsSize, sizeof(int), compare);
    *returnSize = 0;
    return NULL;
}` },
{ name: "C#", lang: "csharp", code: `using System;
using System.Collections.Generic;

class Solution {
    public IList<IList<int>> FourSum(int[] nums, int target) {
        Array.Sort(nums);
        int n = nums.Length;
        var resultSet = new HashSet<(int, int, int, int)>();
        
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                for (int k = j + 1; k < n; k++) {
                    for (int l = k + 1; l < n; l++) {
                        long sum = (long)nums[i] + nums[j] + nums[k] + nums[l];
                        if (sum == target) {
                            resultSet.Add((nums[i], nums[j], nums[k], nums[l]));
                        }
                    }
                }
            }
        }
        
        var result = new List<IList<int>>();
        foreach (var quad in resultSet) {
            result.Add(new List<int> { quad.Item1, quad.Item2, quad.Item3, quad.Item4 });
        }
        
        return result;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function fourSum(nums: number[], target: number): number[][] {
    nums.sort((a, b) => a - b);
    const n = nums.length;
    const resultSet = new Set<string>();
    
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            for (let k = j + 1; k < n; k++) {
                for (let l = k + 1; l < n; l++) {
                    if (nums[i] + nums[j] + nums[k] + nums[l] === target) {
                        const quadruplet = [nums[i], nums[j], nums[k], nums[l]];
                        resultSet.add(JSON.stringify(quadruplet));
                    }
                }
            }
        }
    }
    
    return Array.from(resultSet).map(str => JSON.parse(str));
};` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {
        let sortedNums = nums.sorted()
        let n = sortedNums.count
        var resultSet = Set<[Int]>()
        
        for i in 0..<n {
            for j in (i+1)..<n {
                for k in (j+1)..<n {
                    for l in (k+1)..<n {
                        if sortedNums[i] + sortedNums[j] + sortedNums[k] + sortedNums[l] == target {
                            resultSet.insert([sortedNums[i], sortedNums[j], sortedNums[k], sortedNums[l]])
                        }
                    }
                }
            }
        }
        
        return Array(resultSet)
    }
}` }]} />

**Complexity**

- Time: O(n^4), where n is the length of the input array. We have four nested loops, each potentially iterating through all elements.
- Space: O(k), where k is the number of unique quadruplets in the result. This is for storing the output. The set used for deduplication also contributes to space complexity.
- Notes: This approach is highly inefficient for large inputs due to its quartic time complexity. However, it's conceptually simple and guarantees correctness. It's only suitable for very small input sizes.

---

## Optimized Two-Pointer Technique

**Intuition**

Building upon the classic 3Sum problem, we can apply a similar technique with two fixed pointers and two moving pointers. First, sort the array. Then, fix the first two elements and use two pointers to find the remaining two elements whose sum complements the fixed elements to reach the target.

**Steps**

- Sort the input array to utilize the two-pointer technique and efficiently skip duplicates.
- Iterate through the array with the first pointer (i) from 0 to n-4.
- For each i, iterate with the second pointer (j) from i+1 to n-3.
- For each pair (i,j), use two pointers: left starting at j+1 and right at n-1.
- Calculate the sum of elements at positions i, j, left, and right.
- If the sum equals target, add the quadruplet to the result and move both pointers inward, skipping duplicates.
- If the sum is less than target, increment left to increase the sum.
- If the sum is greater than target, decrement right to decrease the sum.
- Carefully skip duplicate elements for all four pointers to ensure unique quadruplets.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `from typing import List

def fourSum_optimized(nums: List[int], target: int) -> List[List[int]]:
    nums.sort()
    n = len(nums)
    result = []
    
    for i in range(n - 3):
        # Skip duplicate values for i
        if i > 0 and nums[i] == nums[i-1]:
            continue
            
        for j in range(i + 1, n - 2):
            # Skip duplicate values for j
            if j > i + 1 and nums[j] == nums[j-1]:
                continue
                
            left, right = j + 1, n - 1
            
            while left < right:
                current_sum = nums[i] + nums[j] + nums[left] + nums[right]
                
                if current_sum == target:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    
                    # Skip duplicates for left
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    # Skip duplicates for right
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                        
                    left += 1
                    right -= 1
                elif current_sum < target:
                    left += 1
                else:
                    right -= 1
    
    return result` },
{ name: "Java", lang: "java", code: `import java.util.*;

class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        int n = nums.length;
        
        for (int i = 0; i < n - 3; i++) {
            // Skip duplicate values for i
            if (i > 0 && nums[i] == nums[i-1]) continue;
            
            for (int j = i + 1; j < n - 2; j++) {
                // Skip duplicate values for j
                if (j > i + 1 && nums[j] == nums[j-1]) continue;
                
                int left = j + 1, right = n - 1;
                
                while (left < right) {
                    long currentSum = (long)nums[i] + nums[j] + nums[left] + nums[right];
                    
                    if (currentSum == target) {
                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                        
                        // Skip duplicates for left
                        while (left < right && nums[left] == nums[left + 1]) left++;
                        // Skip duplicates for right
                        while (left < right && nums[right] == nums[right - 1]) right--;
                        
                        left++;
                        right--;
                    } else if (currentSum < target) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }
        
        return result;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
    nums.sort((a, b) => a - b);
    const result = [];
    const n = nums.length;
    
    for (let i = 0; i < n - 3; i++) {
        // Skip duplicate values for i
        if (i > 0 && nums[i] === nums[i-1]) continue;
        
        for (let j = i + 1; j < n - 2; j++) {
            // Skip duplicate values for j
            if (j > i + 1 && nums[j] === nums[j-1]) continue;
            
            let left = j + 1, right = n - 1;
            
            while (left < right) {
                const currentSum = nums[i] + nums[j] + nums[left] + nums[right];
                
                if (currentSum === target) {
                    result.push([nums[i], nums[j], nums[left], nums[right]]);
                    
                    // Skip duplicates for left
                    while (left < right && nums[left] === nums[left + 1]) left++;
                    // Skip duplicates for right
                    while (left < right && nums[right] === nums[right - 1]) right--;
                    
                    left++;
                    right--;
                } else if (currentSum < target) {
                    left++;
                } else {
                    right--;
                }
            }
        }
    }
    
    return result;
};` },
{ name: "C++", lang: "cpp", code: `#include <vector>
#include <algorithm>

class Solution {
public:
    std::vector<std::vector<int>> fourSum(std::vector<int>& nums, int target) {
        std::sort(nums.begin(), nums.end());
        std::vector<std::vector<int>> result;
        int n = nums.size();
        
        for (int i = 0; i < n - 3; i++) {
            // Skip duplicate values for i
            if (i > 0 && nums[i] == nums[i-1]) continue;
            
            for (int j = i + 1; j < n - 2; j++) {
                // Skip duplicate values for j
                if (j > i + 1 && nums[j] == nums[j-1]) continue;
                
                int left = j + 1, right = n - 1;
                
                while (left < right) {
                    long long currentSum = (long long)nums[i] + nums[j] + nums[left] + nums[right];
                    
                    if (currentSum == target) {
                        result.push_back({nums[i], nums[j], nums[left], nums[right]});
                        
                        // Skip duplicates for left
                        while (left < right && nums[left] == nums[left + 1]) left++;
                        // Skip duplicates for right
                        while (left < right && nums[right] == nums[right - 1]) right--;
                        
                        left++;
                        right--;
                    } else if (currentSum < target) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }
        
        return result;
    }
};` },
{ name: "Python3", lang: "python", code: `from typing import List

class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        n = len(nums)
        result = []
        
        for i in range(n - 3):
            # Skip duplicate values for i
            if i > 0 and nums[i] == nums[i-1]:
                continue
                
            for j in range(i + 1, n - 2):
                # Skip duplicate values for j
                if j > i + 1 and nums[j] == nums[j-1]:
                    continue
                    
                left, right = j + 1, n - 1
                
                while left < right:
                    current_sum = nums[i] + nums[j] + nums[left] + nums[right]
                    
                    if current_sum == target:
                        result.append([nums[i], nums[j], nums[left], nums[right]])
                        
                        # Skip duplicates for left
                        while left < right and nums[left] == nums[left + 1]:
                            left += 1
                        # Skip duplicates for right
                        while left < right and nums[right] == nums[right - 1]:
                            right -= 1
                            
                        left += 1
                        right -= 1
                    elif current_sum < target:
                        left += 1
                    else:
                        right -= 1
        
        return result` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <stdlib.h>

// Comparison function for qsort
int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes){
    // Sort the array
    qsort(nums, numsSize, sizeof(int), compare);
    
    // Allocate memory for result (worst case)
    int capacity = 1000; // Initial capacity
    int** result = (int**)malloc(capacity * sizeof(int*));
    *returnColumnSizes = (int*)malloc(capacity * sizeof(int));
    *returnSize = 0;
    
    for (int i = 0; i < numsSize - 3; i++) {
        // Skip duplicate values for i
        if (i > 0 && nums[i] == nums[i-1]) continue;
        
        for (int j = i + 1; j < numsSize - 2; j++) {
            // Skip duplicate values for j
            if (j > i + 1 && nums[j] == nums[j-1]) continue;
            
            int left = j + 1, right = numsSize - 1;
            
            while (left < right) {
                long long currentSum = (long long)nums[i] + nums[j] + nums[left] + nums[right];
                
                if (currentSum == target) {
                    // Check if we need to resize
                    if (*returnSize >= capacity) {
                        capacity *= 2;
                        result = (int**)realloc(result, capacity * sizeof(int*));
                        *returnColumnSizes = (int*)realloc(*returnColumnSizes, capacity * sizeof(int));
                    }
                    
                    // Add quadruplet to result
                    result[*returnSize] = (int*)malloc(4 * sizeof(int));
                    result[*returnSize][0] = nums[i];
                    result[*returnSize][1] = nums[j];
                    result[*returnSize][2] = nums[left];
                    result[*returnSize][3] = nums[right];
                    (*returnColumnSizes)[*returnSize] = 4;
                    (*returnSize)++;
                    
                    // Skip duplicates for left
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    // Skip duplicates for right
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    
                    left++;
                    right--;
                } else if (currentSum < target) {
                    left++;
                } else {
                    right--;
                }
            }
        }
    }
    
    return result;
}` },
{ name: "C#", lang: "csharp", code: `using System;
using System.Collections.Generic;

class Solution {
    public IList<IList<int>> FourSum(int[] nums, int target) {
        Array.Sort(nums);
        var result = new List<IList<int>>();
        int n = nums.Length;
        
        for (int i = 0; i < n - 3; i++) {
            // Skip duplicate values for i
            if (i > 0 && nums[i] == nums[i-1]) continue;
            
            for (int j = i + 1; j < n - 2; j++) {
                // Skip duplicate values for j
                if (j > i + 1 && nums[j] == nums[j-1]) continue;
                
                int left = j + 1, right = n - 1;
                
                while (left < right) {
                    long currentSum = (long)nums[i] + nums[j] + nums[left] + nums[right];
                    
                    if (currentSum == target) {
                        result.Add(new List<int> { nums[i], nums[j], nums[left], nums[right] });
                        
                        // Skip duplicates for left
                        while (left < right && nums[left] == nums[left + 1]) left++;
                        // Skip duplicates for right
                        while (left < right && nums[right] == nums[right - 1]) right--;
                        
                        left++;
                        right--;
                    } else if (currentSum < target) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }
        
        return result;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function fourSum(nums: number[], target: number): number[][] {
    nums.sort((a, b) => a - b);
    const result: number[][] = [];
    const n = nums.length;
    
    for (let i = 0; i < n - 3; i++) {
        // Skip duplicate values for i
        if (i > 0 && nums[i] === nums[i-1]) continue;
        
        for (let j = i + 1; j < n - 2; j++) {
            // Skip duplicate values for j
            if (j > i + 1 && nums[j] === nums[j-1]) continue;
            
            let left = j + 1, right = n - 1;
            
            while (left < right) {
                const currentSum = nums[i] + nums[j] + nums[left] + nums[right];
                
                if (currentSum === target) {
                    result.push([nums[i], nums[j], nums[left], nums[right]]);
                    
                    // Skip duplicates for left
                    while (left < right && nums[left] === nums[left + 1]) left++;
                    // Skip duplicates for right
                    while (left < right && nums[right] === nums[right - 1]) right--;
                    
                    left++;
                    right--;
                } else if (currentSum < target) {
                    left++;
                } else {
                    right--;
                }
            }
        }
    }
    
    return result;
};` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {
        let sortedNums = nums.sorted()
        var result: [[Int]] = []
        let n = sortedNums.count
        
        for i in 0..<n-3 {
            // Skip duplicate values for i
            if i > 0 && sortedNums[i] == sortedNums[i-1] { continue }
            
            for j in (i+1)..<n-2 {
                // Skip duplicate values for j
                if j > i + 1 && sortedNums[j] == sortedNums[j-1] { continue }
                
                var left = j + 1
                var right = n - 1
                
                while left < right {
                    let currentSum = sortedNums[i] + sortedNums[j] + sortedNums[left] + sortedNums[right]
                    
                    if currentSum == target {
                        result.append([sortedNums[i], sortedNums[j], sortedNums[left], sortedNums[right]])
                        
                        // Skip duplicates for left
                        while left < right && sortedNums[left] == sortedNums[left + 1] { left += 1 }
                        // Skip duplicates for right
                        while left < right && sortedNums[right] == sortedNums[right - 1] { right -= 1 }
                        
                        left += 1
                        right -= 1
                    } else if currentSum < target {
                        left += 1
                    } else {
                        right -= 1
                    }
                }
            }
        }
        
        return result
    }
}` }]} />

**Complexity**

- Time: O(n^3), where n is the length of the input array. The outer two loops run in O(n^2) time, and the inner two-pointer search takes O(n) time.
- Space: O(1) excluding the space used for the output. We only use a constant amount of extra space for pointers and variables.
- Notes: This is the optimal solution for the 4Sum problem. It's significantly more efficient than the brute force approach. The key insight is using the two-pointer technique after sorting to reduce the search space from O(n^2) to O(n). Careful handling of duplicates is crucial for correctness.

---

## Generalized K-Sum with Recursion

**Intuition**

The 4Sum problem is a specific case of the more general K-Sum problem. We can solve it recursively by reducing it to a (K-1)-Sum problem at each step until we reach the base case of 2Sum, which can be solved efficiently with the two-pointer technique.

**Steps**

- First, sort the input array to enable the two-pointer technique and efficient duplicate skipping.
- Implement a recursive function that takes the array, target, start index, and k (number of elements to sum) as parameters.
- Base case: When k=2, solve using the two-pointer technique for 2Sum.
- Recursive case: For k>2, iterate through the array from the start index, choosing one element at a time.
- For each chosen element, recursively solve the (k-1)Sum problem with the remaining target (target - chosen element) and the subarray starting after the chosen element.
- Combine the chosen element with each solution from the recursive call to form complete k-element combinations.
- Implement careful duplicate skipping at each level of recursion to ensure unique combinations.
- Handle integer overflow by using appropriate data types for sum calculations.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `from typing import List

class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        def kSum(nums: List[int], target: int, k: int, start: int) -> List[List[int]]:
            result = []
            
            # Base case: 2Sum
            if k == 2:
                left, right = start, len(nums) - 1
                while left < right:
                    current_sum = nums[left] + nums[right]
                    if current_sum == target:
                        result.append([nums[left], nums[right]])
                        # Skip duplicates
                        while left < right and nums[left] == nums[left + 1]:
                            left += 1
                        while left < right and nums[right] == nums[right - 1]:
                            right -= 1
                        left += 1
                        right -= 1
                    elif current_sum < target:
                        left += 1
                    else:
                        right -= 1
                return result
            
            # Recursive case: kSum for k > 2
            for i in range(start, len(nums) - k + 1):
                # Skip duplicates
                if i > start and nums[i] == nums[i-1]:
                    continue
                
                # Early termination optimizations
                if nums[i] * k > target:  # All remaining values are too large
                    break
                if nums[-1] * k < target:  # Even the largest value is too small
                    break
                
                # Recursively solve (k-1)Sum
                subsets = kSum(nums, target - nums[i], k - 1, i + 1)
                for subset in subsets:
                    result.append([nums[i]] + subset)
            
            return result
        
        nums.sort()
        return kSum(nums, target, 4, 0)` },
{ name: "Java", lang: "java", code: `import java.util.*;

class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        return kSum(nums, (long)target, 4, 0);
    }
    
    private List<List<Integer>> kSum(int[] nums, long target, int k, int start) {
        List<List<Integer>> result = new ArrayList<>();
        
        // Base case: 2Sum
        if (k == 2) {
            int left = start, right = nums.length - 1;
            while (left < right) {
                long currentSum = (long)nums[left] + nums[right];
                if (currentSum == target) {
                    result.add(Arrays.asList(nums[left], nums[right]));
                    // Skip duplicates
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                } else if (currentSum < target) {
                    left++;
                } else {
                    right--;
                }
            }
            return result;
        }
        
        // Recursive case: kSum for k > 2
        for (int i = start; i < nums.length - k + 1; i++) {
            // Skip duplicates
            if (i > start && nums[i] == nums[i-1]) continue;
            
            // Early termination optimizations
            if ((long)nums[i] * k > target) break;  // All remaining values are too large
            if ((long)nums[nums.length - 1] * k < target) break;  // Even the largest value is too small
            
            // Recursively solve (k-1)Sum
            List<List<Integer>> subsets = kSum(nums, target - nums[i], k - 1, i + 1);
            for (List<Integer> subset : subsets) {
                List<Integer> newSubset = new ArrayList<>();
                newSubset.add(nums[i]);
                newSubset.addAll(subset);
                result.add(newSubset);
            }
        }
        
        return result;
    }
}` },
{ name: "JavaScript", lang: "javascript", code: `/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
    nums.sort((a, b) => a - b);
    
    function kSum(nums, target, k, start) {
        const result = [];
        
        // Base case: 2Sum
        if (k === 2) {
            let left = start, right = nums.length - 1;
            while (left < right) {
                const currentSum = nums[left] + nums[right];
                if (currentSum === target) {
                    result.push([nums[left], nums[right]]);
                    // Skip duplicates
                    while (left < right && nums[left] === nums[left + 1]) left++;
                    while (left < right && nums[right] === nums[right - 1]) right--;
                    left++;
                    right--;
                } else if (currentSum < target) {
                    left++;
                } else {
                    right--;
                }
            }
            return result;
        }
        
        // Recursive case: kSum for k > 2
        for (let i = start; i < nums.length - k + 1; i++) {
            // Skip duplicates
            if (i > start && nums[i] === nums[i-1]) continue;
            
            // Early termination optimizations
            if (nums[i] * k > target) break;  // All remaining values are too large
            if (nums[nums.length - 1] * k < target) break;  // Even the largest value is too small
            
            // Recursively solve (k-1)Sum
            const subsets = kSum(nums, target - nums[i], k - 1, i + 1);
            for (const subset of subsets) {
                result.push([nums[i], ...subset]);
            }
        }
        
        return result;
    }
    
    return kSum(nums, target, 4, 0);
};` },
{ name: "C++", lang: "cpp", code: `#include <vector>
#include <algorithm>

class Solution {
public:
    std::vector<std::vector<int>> fourSum(std::vector<int>& nums, int target) {
        std::sort(nums.begin(), nums.end());
        return kSum(nums, (long long)target, 4, 0);
    }
    
private:
    std::vector<std::vector<int>> kSum(std::vector<int>& nums, long long target, int k, int start) {
        std::vector<std::vector<int>> result;
        
        // Base case: 2Sum
        if (k == 2) {
            int left = start, right = nums.size() - 1;
            while (left < right) {
                long long currentSum = (long long)nums[left] + nums[right];
                if (currentSum == target) {
                    result.push_back({nums[left], nums[right]});
                    // Skip duplicates
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                } else if (currentSum < target) {
                    left++;
                } else {
                    right--;
                }
            }
            return result;
        }
        
        // Recursive case: kSum for k > 2
        for (int i = start; i < (int)nums.size() - k + 1; i++) {
            // Skip duplicates
            if (i > start && nums[i] == nums[i-1]) continue;
            
            // Early termination optimizations
            if ((long long)nums[i] * k > target) break;  // All remaining values are too large
            if ((long long)nums.back() * k < target) break;  // Even the largest value is too small
            
            // Recursively solve (k-1)Sum
            std::vector<std::vector<int>> subsets = kSum(nums, target - nums[i], k - 1, i + 1);
            for (const auto& subset : subsets) {
                std::vector<int> newSubset = {nums[i]};
                newSubset.insert(newSubset.end(), subset.begin(), subset.end());
                result.push_back(newSubset);
            }
        }
        
        return result;
    }
};` },
{ name: "Python3", lang: "python", code: `from typing import List

class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        def kSum(nums: List[int], target: int, k: int, start: int) -> List[List[int]]:
            result = []
            
            # Base case: 2Sum
            if k == 2:
                left, right = start, len(nums) - 1
                while left < right:
                    current_sum = nums[left] + nums[right]
                    if current_sum == target:
                        result.append([nums[left], nums[right]])
                        # Skip duplicates
                        while left < right and nums[left] == nums[left + 1]:
                            left += 1
                        while left < right and nums[right] == nums[right - 1]:
                            right -= 1
                        left += 1
                        right -= 1
                    elif current_sum < target:
                        left += 1
                    else:
                        right -= 1
                return result
            
            # Recursive case: kSum for k > 2
            for i in range(start, len(nums) - k + 1):
                # Skip duplicates
                if i > start and nums[i] == nums[i-1]:
                    continue
                
                # Early termination optimizations
                if nums[i] * k > target:  # All remaining values are too large
                    break
                if nums[-1] * k < target:  # Even the largest value is too small
                    break
                
                # Recursively solve (k-1)Sum
                subsets = kSum(nums, target - nums[i], k - 1, i + 1)
                for subset in subsets:
                    result.append([nums[i]] + subset)
            
            return result
        
        nums.sort()
        return kSum(nums, target, 4, 0)` },
{ name: "C", lang: "c", code: `#include <stdio.h>
#include <stdlib.h>

// Comparison function for qsort
int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

// This would be a complex implementation in C requiring dynamic memory management
// and careful handling of arrays of arrays, which is outside the scope of this example
int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes){
    // Sort the array
    qsort(nums, numsSize, sizeof(int), compare);
    *returnSize = 0;
    return NULL; // Placeholder
}` },
{ name: "C#", lang: "csharp", code: `using System;
using System.Collections.Generic;

class Solution {
    public IList<IList<int>> FourSum(int[] nums, int target) {
        Array.Sort(nums);
        return KSum(nums, (long)target, 4, 0);
    }
    
    private IList<IList<int>> KSum(int[] nums, long target, int k, int start) {
        var result = new List<IList<int>>();
        
        // Base case: 2Sum
        if (k == 2) {
            int left = start, right = nums.Length - 1;
            while (left < right) {
                long currentSum = (long)nums[left] + nums[right];
                if (currentSum == target) {
                    result.Add(new List<int> { nums[left], nums[right] });
                    // Skip duplicates
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                } else if (currentSum < target) {
                    left++;
                } else {
                    right--;
                }
            }
            return result;
        }
        
        // Recursive case: kSum for k > 2
        for (int i = start; i < nums.Length - k + 1; i++) {
            // Skip duplicates
            if (i > start && nums[i] == nums[i-1]) continue;
            
            // Early termination optimizations
            if ((long)nums[i] * k > target) break;  // All remaining values are too large
            if ((long)nums[nums.Length - 1] * k < target) break;  // Even the largest value is too small
            
            // Recursively solve (k-1)Sum
            var subsets = KSum(nums, target - nums[i], k - 1, i + 1);
            foreach (var subset in subsets) {
                var newSubset = new List<int> { nums[i] };
                newSubset.AddRange(subset);
                result.Add(newSubset);
            }
        }
        
        return result;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function fourSum(nums: number[], target: number): number[][] {
    nums.sort((a, b) => a - b);
    
    function kSum(nums: number[], target: number, k: number, start: number): number[][] {
        const result: number[][] = [];
        
        // Base case: 2Sum
        if (k === 2) {
            let left = start, right = nums.length - 1;
            while (left < right) {
                const currentSum = nums[left] + nums[right];
                if (currentSum === target) {
                    result.push([nums[left], nums[right]]);
                    // Skip duplicates
                    while (left < right && nums[left] === nums[left + 1]) left++;
                    while (left < right && nums[right] === nums[right - 1]) right--;
                    left++;
                    right--;
                } else if (currentSum < target) {
                    left++;
                } else {
                    right--;
                }
            }
            return result;
        }
        
        // Recursive case: kSum for k > 2
        for (let i = start; i < nums.length - k + 1; i++) {
            // Skip duplicates
            if (i > start && nums[i] === nums[i-1]) continue;
            
            // Early termination optimizations
            if (nums[i] * k > target) break;  // All remaining values are too large
            if (nums[nums.length - 1] * k < target) break;  // Even the largest value is too small
            
            // Recursively solve (k-1)Sum
            const subsets = kSum(nums, target - nums[i], k - 1, i + 1);
            for (const subset of subsets) {
                result.push([nums[i], ...subset]);
            }
        }
        
        return result;
    }
    
    return kSum(nums, target, 4, 0);
};` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func fourSum(_ nums: [Int], _ target: Int) -> [[Int]] {
        let sortedNums = nums.sorted()
        return kSum(sortedNums, target, 4, 0)
    }
    
    private func kSum(_ nums: [Int], _ target: Int, _ k: Int, _ start: Int) -> [[Int]] {
        var result: [[Int]] = []
        
        // Base case: 2Sum
        if k == 2 {
            var left = start
            var right = nums.count - 1
            while left < right {
                let currentSum = nums[left] + nums[right]
                if currentSum == target {
                    result.append([nums[left], nums[right]])
                    // Skip duplicates
                    while left < right && nums[left] == nums[left + 1] { left += 1 }
                    while left < right && nums[right] == nums[right - 1] { right -= 1 }
                    left += 1
                    right -= 1
                } else if currentSum < target {
                    left += 1
                } else {
                    right -= 1
                }
            }
            return result
        }
        
        // Recursive case: kSum for k > 2
        for i in start..<nums.count - k + 1 {
            // Skip duplicates
            if i > start && nums[i] == nums[i-1] { continue }
            
            // Early termination optimizations
            if nums[i] * k > target { break }  // All remaining values are too large
            if nums.last! * k < target { break }  // Even the largest value is too small
            
            // Recursively solve (k-1)Sum
            let subsets = kSum(nums, target - nums[i], k - 1, i + 1)
            for subset in subsets {
                result.append([nums[i]] + subset)
            }
        }
        
        return result
    }
}` }]} />

**Complexity**

- Time: O(n^(k-1)) or O(n^3) for 4Sum, where n is the length of the input array. For the base 2Sum problem, we use O(n) time with two pointers. For each additional element we need to find, we multiply by a factor of n.
- Space: O(k) for the recursion stack depth, which is O(1) for 4Sum since k is constant. The space for the output is not counted in space complexity analysis.
- Notes: This is a generalized solution that works for any k-Sum problem. It demonstrates the power of recursion and reduction. While it has the same time complexity as the direct 4Sum approach, it's more flexible and can be easily adapted for 3Sum, 5Sum, etc. The early termination optimizations significantly improve practical performance by pruning search branches that cannot lead to valid solutions.


<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"TechArticle","headline":"LeetCode 4Sum Solutions","datePublished":"2025-09-09T19:03:30.598Z","description":"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that: 0 <= a, b, c, d < n; a, b, c...","keywords":"LeetCode, 4Sum, Medium, Array, Two Pointers, Sorting, Hash Map, Brute Force"}).replace(/</g,'\\u003c')}
</script>

<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"Brute Force with Sorting and Nested Loops complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n^4), where n is the length of the input array. We have four nested loops, each potentially iterating through all elements.; Space: O(k), where k is the number of unique quadruplets in the result. This is for storing the output. The set used for deduplication also contributes to space complexity.. This approach is highly inefficient for large inputs due to its quartic time complexity. However, it's conceptually simple and guarantees correctness. It's only suitable for very small input sizes."}},{"@type":"Question","name":"Optimized Two-Pointer Technique complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n^3), where n is the length of the input array. The outer two loops run in O(n^2) time, and the inner two-pointer search takes O(n) time.; Space: O(1) excluding the space used for the output. We only use a constant amount of extra space for pointers and variables.. This is the optimal solution for the 4Sum problem. It's significantly more efficient than the brute force approach. The key insight is using the two-pointer technique after sorting to reduce the search space from O(n^2) to O(n). Careful handling of duplicates is crucial for correctness."}},{"@type":"Question","name":"Generalized K-Sum with Recursion complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n^(k-1)) or O(n^3) for 4Sum, where n is the length of the input array. For the base 2Sum problem, we use O(n) time with two pointers. For each additional element we need to find, we multiply by a factor of n.; Space: O(k) for the recursion stack depth, which is O(1) for 4Sum since k is constant. The space for the output is not counted in space complexity analysis.. This is a generalized solution that works for any k-Sum problem. It demonstrates the power of recursion and reduction. While it has the same time complexity as the direct 4Sum approach, it's more flexible and can be easily adapted for 3Sum, 5Sum, etc. The early termination optimizations significantly improve practical performance by pruning search branches that cannot lead to valid solutions."}}]}).replace(/</g,'\\u003c')}
</script>
