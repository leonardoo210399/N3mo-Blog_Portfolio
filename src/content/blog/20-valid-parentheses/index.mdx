---
title: "Valid Parentheses"
summary: "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type."
date: "Sep 10, 2025"
tags:
  - String
  - Stack
draft: false
difficulty: "Easy"
---

import CodeTabs from "@components/CodeTabs"

> **Difficulty:** Easy | **Acceptance:** 42.75% | **Paid:** No

> **Topics:** String, Stack

- Examples
- Constraints
- [Brute Force - Repeated Removal](#brute-force-repeated-removal)
- [Stack-Based Solution](#stack-based-solution)
- [Array-Based Stack Simulation](#array-based-stack-simulation)

## Examples

**Input**

```text
s = "()"
```

**Output**

```text
true
```

**Input**

```text
s = "()[]{}"
```

**Output**

```text
true
```

**Input**

```text
s = "(]"
```

**Output**

```text
false
```

## Constraints

```text
- 1 <= s.length <= 10^4
- s consists of parentheses only '()[]{}'.
```
---

## Brute Force - Repeated Removal

**Intuition**

We can iteratively remove valid pairs of parentheses until no more pairs can be removed. If the result is an empty string, then all brackets were properly matched.

**Steps**

- Continuously scan the string for valid pairs like '()', '{}', and '[]'.
- When a valid pair is found, remove it from the string.
- Repeat this process until no more pairs are found. If the final string is empty, return true; otherwise, return false.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def isValid(s: str) -> bool:
    while '()' in s or '{}' in s or '[]' in s:
        s = s.replace('()', '').replace('{}', '').replace('[]', '')
    return not s` },
{ name: "Java", lang: "java", code: `public boolean isValid(String s) {
    while (s.contains("()") || s.contains("{}") || s.contains("[]")) {
        s = s.replace("()", "").replace("{}", "").replace("[]", "");
    }
    return s.isEmpty();
}` },
{ name: "JavaScript", lang: "javascript", code: `var isValid = function(s) {
    while (s.includes('()') || s.includes('{}') || s.includes('[]')) {
        s = s.replace('()', '').replace('{}', '').replace('[]', '');
    }
    return s === '';
};` },
{ name: "C++", lang: "cpp", code: `#include <string>
using namespace std;

class Solution {
public:
    bool isValid(string s) {
        while (s.find("()") != string::npos || s.find("{}") != string::npos || s.find("[]") != string::npos) {
            size_t pos;
            if ((pos = s.find("()")) != string::npos) s.erase(pos, 2);
            else if ((pos = s.find("{}")) != string::npos) s.erase(pos, 2);
            else if ((pos = s.find("[]")) != string::npos) s.erase(pos, 2);
        }
        return s.empty();
    }
};` },
{ name: "Python3", lang: "python", code: `def isValid(self, s: str) -> bool:
    while '()' in s or '{}' in s or '[]' in s:
        s = s.replace('()', '').replace('{}', '').replace('[]', '')
    return not s` },
{ name: "C", lang: "c", code: `#include <string.h>
#include <stdbool.h>

bool isValid(char* s) {
    int len = strlen(s);
    while (1) {
        int found = 0;
        for (int i = 0; i < len - 1; i++) {
            if ((s[i] == '(' && s[i+1] == ')') || 
                (s[i] == '{' && s[i+1] == '}') || 
                (s[i] == '[' && s[i+1] == ']')) {
                // Shift the rest of the string left by 2
                memmove(&s[i], &s[i+2], len - i - 1);
                len -= 2;
                found = 1;
                break;
            }
        }
        if (!found) break;
    }
    return len == 0;
}` },
{ name: "C#", lang: "csharp", code: `public class Solution {
    public bool IsValid(string s) {
        while (s.Contains("()") || s.Contains("{}") || s.Contains("[]")) {
            s = s.Replace("()", "").Replace("{}", "").Replace("[]", "");
        }
        return s.Length == 0;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function isValid(s: string): boolean {
    while (s.includes('()') || s.includes('{}') || s.includes('[]')) {
        s = s.replace('()', '').replace('{}', '').replace('[]', '');
    }
    return s === '';
}` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func isValid(_ s: String) -> Bool {
        var str = s
        while str.contains("()") || str.contains("{}") || str.contains("[]") {
            str = str.replacingOccurrences(of: "()", with: "")
                     .replacingOccurrences(of: "{}", with: "")
                     .replacingOccurrences(of: "[]", with: "")
        }
        return str.isEmpty
    }
}` }]} />

**Complexity**

- Time: O(n^2) - In the worst case, we process the string O(n) times, each time scanning O(n) characters.
- Space: O(1) - No additional data structures are used in this approach.

---

## Stack-Based Solution

**Intuition**

Use a stack to track opening brackets. When a closing bracket is encountered, check if it matches the most recent opening bracket (at the top of the stack). This naturally ensures correct ordering.

**Steps**

- Initialize an empty stack to store opening brackets.
- Iterate through each character in the string.
- If the character is an opening bracket ('(', '{', '['), push it onto the stack.
- If the character is a closing bracket, check the top of the stack to see if it matches. If it does, pop the stack. If not, or if the stack is empty, return false.
- After processing all characters, if the stack is empty, the string is valid; otherwise, it's not.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def isValid(s: str) -> bool:
    stack = []
    mapping = {")": "(", "}": "{", "]": "["}
    
    for char in s:
        if char in mapping.values():
            stack.append(char)
        elif char in mapping.keys():
            if not stack or mapping[char] != stack.pop():
                return False
        else:
            return False
            
    return not stack` },
{ name: "Java", lang: "java", code: `import java.util.*;

public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    Map<Character, Character> mapping = new HashMap<>();
    mapping.put(')', '(');
    mapping.put('}', '{');
    mapping.put(']', '[');
    
    for (char c : s.toCharArray()) {
        if (mapping.containsValue(c)) {
            stack.push(c);
        } else if (mapping.containsKey(c)) {
            if (stack.isEmpty() || mapping.get(c) != stack.pop()) {
                return false;
            }
        }
    }
    
    return stack.isEmpty();
}` },
{ name: "JavaScript", lang: "javascript", code: `var isValid = function(s) {
    const stack = [];
    const mapping = {')': '(', '}': '{', ']': '['};
    
    for (let char of s) {
        if (Object.values(mapping).includes(char)) {
            stack.push(char);
        } else if (Object.keys(mapping).includes(char)) {
            if (stack.length === 0 || mapping[char] !== stack.pop()) {
                return false;
            }
        }
    }
    
    return stack.length === 0;
};` },
{ name: "C++", lang: "cpp", code: `#include <stack>
#include <unordered_map>
using namespace std;

class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        unordered_map<char, char> mapping = {{')', '('}, {'}', '{'}, {']', '['}};
        
        for (char c : s) {
            if (mapping.find(c) == mapping.end()) {
                st.push(c);
            } else {
                if (st.empty() || mapping[c] != st.top()) {
                    return false;
                }
                st.pop();
            }
        }
        
        return st.empty();
    }
};` },
{ name: "Python3", lang: "python", code: `def isValid(self, s: str) -> bool:
    stack = []
    mapping = {")": "(", "}": "{", "]": "["}
    
    for char in s:
        if char in mapping.values():
            stack.append(char)
        elif char in mapping.keys():
            if not stack or mapping[char] != stack.pop():
                return False
        else:
            return False
            
    return not stack` },
{ name: "C", lang: "c", code: `#include <stdbool.h>

bool isValid(char* s) {
    char stack[10000];
    int top = -1;
    
    for (int i = 0; s[i] != '\0'; i++) {
        char c = s[i];
        
        if (c == '(' || c == '{' || c == '[') {
            stack[++top] = c;
        } else {
            if (top == -1) return false;
            
            char topChar = stack[top--];
            if ((c == ')' && topChar != '(') ||
                (c == '}' && topChar != '{') ||
                (c == ']' && topChar != '[')) {
                return false;
            }
        }
    }
    
    return top == -1;
}` },
{ name: "C#", lang: "csharp", code: `using System.Collections.Generic;

public class Solution {
    public bool IsValid(string s) {
        Stack<char> stack = new Stack<char>();
        Dictionary<char, char> mapping = new Dictionary<char, char>() {
            {')', '('}, {'}', '{'}, {']', '['}
        };
        
        foreach (char c in s) {
            if (mapping.ContainsValue(c)) {
                stack.Push(c);
            } else if (mapping.ContainsKey(c)) {
                if (stack.Count == 0 || mapping[c] != stack.Pop()) {
                    return false;
                }
            }
        }
        
        return stack.Count == 0;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function isValid(s: string): boolean {
    const stack: string[] = [];
    const mapping: { [key: string]: string } = {')': '(', '}': '{', ']': '['};
    
    for (const char of s) {
        if (Object.values(mapping).includes(char)) {
            stack.push(char);
        } else if (Object.keys(mapping).includes(char)) {
            if (stack.length === 0 || mapping[char] !== stack.pop()) {
                return false;
            }
        }
    }
    
    return stack.length === 0;
}` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func isValid(_ s: String) -> Bool {
        var stack: [Character] = []
        let mapping: [Character: Character] = [")": "(", "}" : "{", "]": "["]
        
        for char in s {
            if mapping.values.contains(char) {
                stack.append(char)
            } else if mapping.keys.contains(char) {
                if stack.isEmpty || mapping[char] != stack.removeLast() {
                    return false
                }
            }
        }
        
        return stack.isEmpty
    }
}` }]} />

**Complexity**

- Time: O(n) - We traverse the string exactly once.
- Space: O(n) - In the worst case, all characters might be opening brackets and stored in the stack.

---

## Array-Based Stack Simulation

**Intuition**

Since we know the maximum possible length of the input, we can simulate a stack with a fixed-size array instead of using dynamic data structures like Stack or ArrayList. This can reduce constant factors in some implementations.

**Steps**

- Create a fixed-size array (with size equal to string length) to act as a stack.
- Use an index pointer to track the top of the stack.
- For each character in the input string:
- If it's an opening bracket, place it at the current top index and increment the pointer.
- If it's a closing bracket, check if the element at (top-1) index matches. If yes, decrement the pointer. If no, or if stack is empty, return false.
- Finally, check if the stack pointer is back to zero.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def isValid(s: str) -> bool:
    if len(s) % 2 != 0:
        return False
        
    stack = [None] * len(s)
    top = 0
    mapping = {")": "(", "}": "{", "]": "["}
    
    for char in s:
        if char in mapping.values():
            stack[top] = char
            top += 1
        elif char in mapping.keys():
            if top == 0 or mapping[char] != stack[top - 1]:
                return False
            top -= 1
    
    return top == 0` },
{ name: "Java", lang: "java", code: `public boolean isValid(String s) {
    if (s.length() % 2 != 0) return false;
    
    char[] stack = new char[s.length()];
    int top = 0;
    java.util.Map<Character, Character> mapping = java.util.Map.of(
        ')', '(', '}', '{', ']', '[');
    
    for (char c : s.toCharArray()) {
        if (mapping.containsValue(c)) {
            stack[top++] = c;
        } else if (mapping.containsKey(c)) {
            if (top == 0 || mapping.get(c) != stack[--top]) {
                return false;
            }
        }
    }
    
    return top == 0;
}` },
{ name: "JavaScript", lang: "javascript", code: `var isValid = function(s) {
    if (s.length % 2 !== 0) return false;
    
    const stack = new Array(s.length);
    let top = 0;
    const mapping = {')': '(', '}': '{', ']': '['};
    
    for (const char of s) {
        if (Object.values(mapping).includes(char)) {
            stack[top++] = char;
        } else if (Object.keys(mapping).includes(char)) {
            if (top === 0 || mapping[char] !== stack[--top]) {
                return false;
            }
        }
    }
    
    return top === 0;
};` },
{ name: "C++", lang: "cpp", code: `#include <unordered_map>
using namespace std;

class Solution {
public:
    bool isValid(string s) {
        if (s.length() % 2 != 0) return false;
        
        char stack[10000];
        int top = 0;
        unordered_map<char, char> mapping = {{')', '('}, {'}', '{'}, {']', '['}};
        
        for (char c : s) {
            if (mapping.find(c) == mapping.end()) {
                stack[top++] = c;
            } else {
                if (top == 0 || mapping[c] != stack[--top]) {
                    return false;
                }
            }
        }
        
        return top == 0;
    }
};` },
{ name: "Python3", lang: "python", code: `def isValid(self, s: str) -> bool:
    if len(s) % 2 != 0:
        return False
        
    stack = [None] * len(s)
    top = 0
    mapping = {")": "(", "}": "{", "]": "["}
    
    for char in s:
        if char in mapping.values():
            stack[top] = char
            top += 1
        elif char in mapping.keys():
            if top == 0 or mapping[char] != stack[top - 1]:
                return False
            top -= 1
    
    return top == 0` },
{ name: "C", lang: "c", code: `#include <stdbool.h>

bool isValid(char* s) {
    int len = 0;
    for(int i=0; s[i]; i++) len++;
    
    if (len % 2 != 0) return false;
    
    char stack[10000];
    int top = 0;
    
    for (int i = 0; s[i] != '\0'; i++) {
        char c = s[i];
        
        if (c == '(' || c == '{' || c == '[') {
            stack[top++] = c;
        } else {
            if (top == 0) return false;
            
            char topChar = stack[--top];
            if ((c == ')' && topChar != '(') ||
                (c == '}' && topChar != '{') ||
                (c == ']' && topChar != '[')) {
                return false;
            }
        }
    }
    
    return top == 0;
}` },
{ name: "C#", lang: "csharp", code: `public class Solution {
    public bool IsValid(string s) {
        if (s.Length % 2 != 0) return false;
        
        char[] stack = new char[s.Length];
        int top = 0;
        Dictionary<char, char> mapping = new Dictionary<char, char> {
            {')', '('}, {'}', '{'}, {']', '['}
        };
        
        foreach (char c in s) {
            if (mapping.ContainsValue(c)) {
                stack[top++] = c;
            } else if (mapping.ContainsKey(c)) {
                if (top == 0 || mapping[c] != stack[--top]) {
                    return false;
                }
            }
        }
        
        return top == 0;
    }
}` },
{ name: "TypeScript", lang: "typescript", code: `function isValid(s: string): boolean {
    if (s.length % 2 !== 0) return false;
    
    const stack: (string | null)[] = new Array(s.length);
    let top = 0;
    const mapping: { [key: string]: string } = {')': '(', '}': '{', ']': '['};
    
    for (const char of s) {
        if (Object.values(mapping).includes(char)) {
            stack[top++] = char;
        } else if (Object.keys(mapping).includes(char)) {
            if (top === 0 || mapping[char] !== stack[--top]) {
                return false;
            }
        }
    }
    
    return top === 0;
}` },
{ name: "Swift", lang: "swift", code: `class Solution {
    func isValid(_ s: String) -> Bool {
        if s.count % 2 != 0 { return false }
        
        var stack = Array<Character?>(repeating: nil, count: s.count)
        var top = 0
        let mapping: [Character: Character] = [")": "(", "}" : "{", "]": "["]
        
        for char in s {
            if mapping.values.contains(char) {
                stack[top] = char
                top += 1
            } else if mapping.keys.contains(char) {
                if top == 0 || mapping[char] != stack[top - 1] {
                    return false
                }
                top -= 1
            }
        }
        
        return top == 0
    }
}` }]} />

**Complexity**

- Time: O(n) - We traverse the string exactly once.
- Space: O(n) - We use an array of size equal to the input string length.
- Notes: The space is pre-allocated which might offer better cache performance in some scenarios compared to a dynamic stack implementation.


<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"TechArticle","headline":"LeetCode Valid Parentheses Solutions","datePublished":"2025-09-10T05:01:56.993Z","description":"Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open br...","keywords":"LeetCode, Valid Parentheses, Easy, String, Stack, Two Pointers, Hash Map, Brute Force, Array"}).replace(/</g,'\\u003c')}
</script>

<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"Brute Force - Repeated Removal complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n^2) - In the worst case, we process the string O(n) times, each time scanning O(n) characters.; Space: O(1) - No additional data structures are used in this approach.. "}},{"@type":"Question","name":"Stack-Based Solution complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n) - We traverse the string exactly once.; Space: O(n) - In the worst case, all characters might be opening brackets and stored in the stack.. "}},{"@type":"Question","name":"Array-Based Stack Simulation complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n) - We traverse the string exactly once.; Space: O(n) - We use an array of size equal to the input string length.. The space is pre-allocated which might offer better cache performance in some scenarios compared to a dynamic stack implementation."}}]}).replace(/</g,'\\u003c')}
</script>
