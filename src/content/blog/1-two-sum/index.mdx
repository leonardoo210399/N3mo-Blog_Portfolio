---
title: "Two Sum"
summary: "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order."
date: "Sep 07, 2025"
tags:
  - Array
  - Hash Table
draft: false
difficulty: "Easy"
---

import CodeTabs from "@components/CodeTabs"

> **Difficulty:** Easy | **Acceptance:** 56.20% | **Paid:** No

> **Topics:** Array, Hash Table

- Examples
- Constraints
- [Brute Force](#brute-force)
- [Hash Map](#hash-map)
- [Two Pointers](#two-pointers)

## Examples

**Input**

```text
nums = [2,7,11,15], target = 9
```

**Output**

```text
[0,1]
```

**Explanation**

Because nums[0] + nums[1] == 9, we return [0, 1].

**Input**

```text
nums = [3,2,4], target = 6
```

**Output**

```text
[1,2]
```

**Input**

```text
nums = [3,3], target = 6
```

**Output**

```text
[0,1]
```

## Constraints

```text
- 2 <= nums.length <= 10^4 
- -10^9 <= nums[i] <= 10^9 
- -10^9 <= target <= 10^9 
- Only one valid answer exists. 
```
---

## Brute Force

**Intuition**

Check every pair of elements to see if they sum to the target.

**Steps**

- Iterate through each element in the array.
- For each element, iterate through the rest of the array to find a complement that sums to the target.
- Return the indices of the two elements that sum to the target.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def twoSum(self, nums: List[int], target: int) -> List[int]:
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []` },
{ name: "Java", lang: "java", code: `public int[] twoSum(int[] nums, int target) {
    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] == target) {
                return new int[] {i, j};
            }
        }
    }
    return new int[] {};
}` },
{ name: "JavaScript", lang: "javascript", code: `var twoSum = function(nums, target) {
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
    return [];
};` },
{ name: "C++", lang: "cpp", code: `vector<int> twoSum(vector<int>& nums, int target) {
    for (int i = 0; i < nums.size(); i++) {
        for (int j = i + 1; j < nums.size(); j++) {
            if (nums[i] + nums[j] == target) {
                return {i, j};
            }
        }
    }
    return {};
}` },
{ name: "Python3", lang: "python", code: `def twoSum(self, nums: List[int], target: int) -> List[int]:
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []` },
{ name: "C", lang: "c", code: `int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    for (int i = 0; i < numsSize; i++) {
        for (int j = i + 1; j < numsSize; j++) {
            if (nums[i] + nums[j] == target) {
                int* result = (int*)malloc(2 * sizeof(int));
                result[0] = i;
                result[1] = j;
                *returnSize = 2;
                return result;
            }
        }
    }
    *returnSize = 0;
    return NULL;
}` },
{ name: "C#", lang: "csharp", code: `public int[] TwoSum(int[] nums, int target) {
    for (int i = 0; i < nums.Length; i++) {
        for (int j = i + 1; j < nums.Length; j++) {
            if (nums[i] + nums[j] == target) {
                return new int[] {i, j};
            }
        }
    }
    return new int[] {};
}` },
{ name: "TypeScript", lang: "typescript", code: `function twoSum(nums: number[], target: number): number[] {
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
    return [];
}` },
{ name: "Swift", lang: "swift", code: `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
    for i in 0..<nums.count {
        for j in (i + 1)..<nums.count {
            if nums[i] + nums[j] == target {
                return [i, j]
            }
        }
    }
    return []
}` }]} />

**Complexity**

- Time: O(n^2)
- Space: O(1)
- Notes: This approach checks all possible pairs which leads to quadratic time complexity.

---

## Hash Map

**Intuition**

Use a hash map to store elements and their indices for faster lookup.

**Steps**

- Iterate through the array once.
- For each element, calculate its complement (target - element).
- Check if the complement exists in the hash map.
- If it does, return the current index and the index of the complement.
- If not, store the current element and its index in the hash map.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def twoSum(self, nums: List[int], target: int) -> List[int]:
    hashmap = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
    return []` },
{ name: "Java", lang: "java", code: `public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> hashmap = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (hashmap.containsKey(complement)) {
            return new int[] {hashmap.get(complement), i};
        }
        hashmap.put(nums[i], i);
    }
    return new int[] {};
}` },
{ name: "JavaScript", lang: "javascript", code: `var twoSum = function(nums, target) {
    const hashmap = new Map();
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (hashmap.has(complement)) {
            return [hashmap.get(complement), i];
        }
        hashmap.set(nums[i], i);
    }
    return [];
};` },
{ name: "C++", lang: "cpp", code: `vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> hashmap;
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (hashmap.find(complement) != hashmap.end()) {
            return {hashmap[complement], i};
        }
        hashmap[nums[i]] = i;
    }
    return {};
}` },
{ name: "Python3", lang: "python", code: `def twoSum(self, nums: List[int], target: int) -> List[int]:
    hashmap = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
    return []` },
{ name: "C", lang: "c", code: `int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    int* hashmap = (int*)calloc(20001, sizeof(int));
    for (int i = 0; i < numsSize; i++) {
        int complement = target - nums[i];
        if (hashmap[complement + 10000] != 0) {
            int* result = (int*)malloc(2 * sizeof(int));
            result[0] = hashmap[complement + 10000] - 1;
            result[1] = i;
            *returnSize = 2;
            free(hashmap);
            return result;
        }
        hashmap[nums[i] + 10000] = i + 1;
    }
    *returnSize = 0;
    free(hashmap);
    return NULL;
}` },
{ name: "C#", lang: "csharp", code: `public int[] TwoSum(int[] nums, int target) {
    Dictionary<int, int> hashmap = new Dictionary<int, int>();
    for (int i = 0; i < nums.Length; i++) {
        int complement = target - nums[i];
        if (hashmap.ContainsKey(complement)) {
            return new int[] {hashmap[complement], i};
        }
        hashmap[nums[i]] = i;
    }
    return new int[] {};
}` },
{ name: "TypeScript", lang: "typescript", code: `function twoSum(nums: number[], target: number): number[] {
    const hashmap = new Map<number, number>();
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (hashmap.has(complement)) {
            return [hashmap.get(complement)!, i];
        }
        hashmap.set(nums[i], i);
    }
    return [];
}` },
{ name: "Swift", lang: "swift", code: `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
    var hashmap = [Int: Int]()
    for (i, num) in nums.enumerated() {
        let complement = target - num
        if let index = hashmap[complement] {
            return [index, i]
        }
        hashmap[num] = i
    }
    return []
}` }]} />

**Complexity**

- Time: O(n)
- Space: O(n)
- Notes: This approach uses extra space for the hash map but reduces time complexity to linear.

---

## Two Pointers

**Intuition**

Sort the array and use two pointers from both ends to find the target sum.

**Steps**

- Create a list of pairs (value, original_index) to keep track of original indices.
- Sort this list based on values.
- Use two pointers, one at the start and one at the end of the sorted list.
- Adjust pointers based on whether the current sum is less than or greater than the target.
- When the sum matches the target, return the original indices.

<CodeTabs client:load tabs={[{ name: "Python", lang: "python", code: `def twoSum(self, nums: List[int], target: int) -> List[int]:
    indexed_nums = [(num, i) for i, num in enumerate(nums)]
    indexed_nums.sort()
    left, right = 0, len(nums) - 1
    while left < right:
        current_sum = indexed_nums[left][0] + indexed_nums[right][0]
        if current_sum == target:
            return [indexed_nums[left][1], indexed_nums[right][1]]
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    return []` },
{ name: "Java", lang: "java", code: `public int[] twoSum(int[] nums, int target) {
    int[][] indexedNums = new int[nums.length][2];
    for (int i = 0; i < nums.length; i++) {
        indexedNums[i][0] = nums[i];
        indexedNums[i][1] = i;
    }
    Arrays.sort(indexedNums, (a, b) -> a[0] - b[0]);
    int left = 0, right = nums.length - 1;
    while (left < right) {
        int currentSum = indexedNums[left][0] + indexedNums[right][0];
        if (currentSum == target) {
            return new int[] {indexedNums[left][1], indexedNums[right][1]};
        } else if (currentSum < target) {
            left++;
        } else {
            right--;
        }
    }
    return new int[] {};
}` },
{ name: "JavaScript", lang: "javascript", code: `var twoSum = function(nums, target) {
    const indexedNums = nums.map((num, i) => [num, i]);
    indexedNums.sort((a, b) => a[0] - b[0]);
    let left = 0, right = nums.length - 1;
    while (left < right) {
        const currentSum = indexedNums[left][0] + indexedNums[right][0];
        if (currentSum === target) {
            return [indexedNums[left][1], indexedNums[right][1]];
        } else if (currentSum < target) {
            left++;
        } else {
            right--;
        }
    }
    return [];
};` },
{ name: "C++", lang: "cpp", code: `vector<int> twoSum(vector<int>& nums, int target) {
    vector<pair<int, int>> indexedNums(nums.size());
    for (int i = 0; i < nums.size(); i++) {
        indexedNums[i] = {nums[i], i};
    }
    sort(indexedNums.begin(), indexedNums.end());
    int left = 0, right = nums.size() - 1;
    while (left < right) {
        int currentSum = indexedNums[left].first + indexedNums[right].first;
        if (currentSum == target) {
            return {indexedNums[left].second, indexedNums[right].second};
        } else if (currentSum < target) {
            left++;
        } else {
            right--;
        }
    }
    return {};
}` },
{ name: "Python3", lang: "python", code: `def twoSum(self, nums: List[int], target: int) -> List[int]:
    indexed_nums = [(num, i) for i, num in enumerate(nums)]
    indexed_nums.sort()
    left, right = 0, len(nums) - 1
    while left < right:
        current_sum = indexed_nums[left][0] + indexed_nums[right][0]
        if current_sum == target:
            return [indexed_nums[left][1], indexed_nums[right][1]]
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    return []` },
{ name: "C", lang: "c", code: `int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    int** indexedNums = (int**)malloc(numsSize * sizeof(int*));
    for (int i = 0; i < numsSize; i++) {
        indexedNums[i] = (int*)malloc(2 * sizeof(int));
        indexedNums[i][0] = nums[i];
        indexedNums[i][1] = i;
    }
    qsort(indexedNums, numsSize, sizeof(int*), compare);
    int left = 0, right = numsSize - 1;
    while (left < right) {
        int currentSum = indexedNums[left][0] + indexedNums[right][0];
        if (currentSum == target) {
            int* result = (int*)malloc(2 * sizeof(int));
            result[0] = indexedNums[left][1];
            result[1] = indexedNums[right][1];
            *returnSize = 2;
            for (int i = 0; i < numsSize; i++) free(indexedNums[i]);
            free(indexedNums);
            return result;
        } else if (currentSum < target) {
            left++;
        } else {
            right--;
        }
    }
    *returnSize = 0;
    for (int i = 0; i < numsSize; i++) free(indexedNums[i]);
    free(indexedNums);
    return NULL;
}` },
{ name: "C#", lang: "csharp", code: `public int[] TwoSum(int[] nums, int target) {
    var indexedNums = nums.Select((num, i) => new { Value = num, Index = i }).ToArray();
    Array.Sort(indexedNums, (a, b) => a.Value.CompareTo(b.Value));
    int left = 0, right = nums.Length - 1;
    while (left < right) {
        int currentSum = indexedNums[left].Value + indexedNums[right].Value;
        if (currentSum == target) {
            return new int[] {indexedNums[left].Index, indexedNums[right].Index};
        } else if (currentSum < target) {
            left++;
        } else {
            right--;
        }
    }
    return new int[] {};
}` },
{ name: "TypeScript", lang: "typescript", code: `function twoSum(nums: number[], target: number): number[] {
    const indexedNums = nums.map((num, i) => [num, i]);
    indexedNums.sort((a, b) => a[0] - b[0]);
    let left = 0, right = nums.length - 1;
    while (left < right) {
        const currentSum = indexedNums[left][0] + indexedNums[right][0];
        if (currentSum === target) {
            return [indexedNums[left][1], indexedNums[right][1]];
        } else if (currentSum < target) {
            left++;
        } else {
            right--;
        }
    }
    return [];
}` },
{ name: "Swift", lang: "swift", code: `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
    let indexedNums = nums.enumerated().sorted { $0.element < $1.element }
    var left = 0
    var right = nums.count - 1
    while left < right {
        let currentSum = indexedNums[left].element + indexedNums[right].element
        if currentSum == target {
            return [indexedNums[left].offset, indexedNums[right].offset]
        } else if currentSum < target {
            left += 1
        } else {
            right -= 1
        }
    }
    return []
}` }]} />

**Complexity**

- Time: O(n log n)
- Space: O(n)
- Notes: This approach sorts the array which takes O(n log n) time. Space is used to store the indexed pairs.


<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"TechArticle","headline":"LeetCode Two Sum Solutions","datePublished":"2025-09-07T09:16:49.152Z","description":"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input woul...","keywords":"LeetCode, Two Sum, Easy, Array, Hash Table, Two Pointers, Hash Map, Brute Force"}).replace(/</g,'\\u003c')}
</script>

<script is:inline type="application/ld+json">
{JSON.stringify({"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"Brute Force complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n^2); Space: O(1). This approach checks all possible pairs which leads to quadratic time complexity."}},{"@type":"Question","name":"Hash Map complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n); Space: O(n). This approach uses extra space for the hash map but reduces time complexity to linear."}},{"@type":"Question","name":"Two Pointers complexity?","acceptedAnswer":{"@type":"Answer","text":"Time: O(n log n); Space: O(n). This approach sorts the array which takes O(n log n) time. Space is used to store the indexed pairs."}}]}).replace(/</g,'\\u003c')}
</script>
